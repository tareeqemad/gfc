PACKAGE BODY hr_attendance_pkg is

---------------------------------------------------------------------------------------------

PROCEDURE EXIT_PERMISSION_TB_INSERT (
EMP_NO_IN  IN EXIT_PERMISSION_TB.EMP_NO%TYPE ,
P_DATE_IN  IN EXIT_PERMISSION_TB.P_DATE%TYPE ,
P_EXIT_TIME_IN  IN  VARCHAR2 ,
P_RET_TIME_IN   IN VARCHAR2 ,
NOTES_EMP_IN  IN EXIT_PERMISSION_TB.NOTES_EMP%TYPE ,
NOTES_OBSERVER_IN  IN EXIT_PERMISSION_TB.NOTES_OBSERVER%TYPE ,
PERMI_TYPE_IN  IN EXIT_PERMISSION_TB.PERMI_TYPE%TYPE ,
PERM_YEAR_IN  IN EXIT_PERMISSION_TB.PERM_YEAR%TYPE ,
destination_IN  IN EXIT_PERMISSION_TB.destination%TYPE ,
MSG_OUT OUT VARCHAR2) AS
SEQ_VAL NUMBER ;
V_EXIT_TIME DATE;
V_RET_TIME DATE;
BEGIN

if P_EXIT_TIME_IN is null then
    V_EXIT_TIME:= '';
ELSE
    V_EXIT_TIME:= TO_DATE(P_DATE_IN||P_EXIT_TIME_IN,'DD/MM/YYYY HH24:MI');
    V_EXIT_TIME:= update_time(V_EXIT_TIME, 5, '+');
END if;

if P_RET_TIME_IN is null then
    V_RET_TIME:= '';
ELSE
    V_RET_TIME:= TO_DATE(P_DATE_IN||P_RET_TIME_IN,'DD/MM/YYYY HH24:MI');
    V_RET_TIME:= update_time(V_RET_TIME, 5, '-');
END if;

SEQ_VAL  := EXIT_PERMISSION_TB_SEQ.NEXTVAL;

INSERT INTO  EXIT_PERMISSION_TB(
SER ,EMP_NO ,P_DATE ,P_EXIT_TIME ,P_RET_TIME ,NOTES_EMP ,NOTES_OBSERVER , ADOPT ,PERMI_TYPE ,PERM_YEAR ,
ENTRY_USER ,ENTRY_DATE ,BRANCH_ID , destination )
 VALUES
(SEQ_VAL ,EMP_NO_IN ,P_DATE_IN , V_EXIT_TIME , V_RET_TIME ,NOTES_EMP_IN ,NOTES_OBSERVER_IN ,1 ,PERMI_TYPE_IN ,PERM_YEAR_IN ,
  USER_PKG.GET_USER_ID  , SYSDATE , USER_PKG.GET_USER_BRANCH_NO , destination_in ) ;

MSG_OUT:= SEQ_VAL ;

EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'EXIT_PERMISSION_TB_INSERT '|| SQLERRM;
END EXIT_PERMISSION_TB_INSERT ;

-------------------------------------------------------------------------------------------------

PROCEDURE EXIT_PERMISSION_TB_UPDATE (
SER_IN  IN EXIT_PERMISSION_TB.SER%TYPE ,
EMP_NO_IN  IN EXIT_PERMISSION_TB.EMP_NO%TYPE ,
P_DATE_IN  IN EXIT_PERMISSION_TB.P_DATE%TYPE ,
P_EXIT_TIME_IN  IN VARCHAR2 ,
P_RET_TIME_IN   IN VARCHAR2 ,
NOTES_EMP_IN  IN EXIT_PERMISSION_TB.NOTES_EMP%TYPE ,
NOTES_OBSERVER_IN  IN EXIT_PERMISSION_TB.NOTES_OBSERVER%TYPE ,
PERMI_TYPE_IN  IN EXIT_PERMISSION_TB.PERMI_TYPE%TYPE ,
PERM_YEAR_IN  IN EXIT_PERMISSION_TB.PERM_YEAR%TYPE ,
destination_IN  IN EXIT_PERMISSION_TB.destination%TYPE ,
MSG_OUT OUT VARCHAR2) AS
V_EXIT_TIME DATE;
V_RET_TIME DATE;
BEGIN

if P_EXIT_TIME_IN is null then
    V_EXIT_TIME:= '';
ELSE
    V_EXIT_TIME:= TO_DATE(P_DATE_IN||P_EXIT_TIME_IN,'DD/MM/YYYY HH24:MI');
    V_EXIT_TIME:= update_time(V_EXIT_TIME, 5, '+');
END if;

if P_RET_TIME_IN is null then
    V_RET_TIME:= '';
ELSE
    V_RET_TIME:= TO_DATE(P_DATE_IN||P_RET_TIME_IN,'DD/MM/YYYY HH24:MI');
    V_RET_TIME:= update_time(V_RET_TIME, 5, '-');
END if;

UPDATE EXIT_PERMISSION_TB SET
    EMP_NO = EMP_NO_IN   ,
    P_DATE = P_DATE_IN   ,
    P_EXIT_TIME = V_EXIT_TIME   ,
    P_RET_TIME = V_RET_TIME   ,
    NOTES_EMP = NOTES_EMP_IN   ,
    NOTES_OBSERVER = NOTES_OBSERVER_IN  ,
    PERMI_TYPE = PERMI_TYPE_IN   ,
    PERM_YEAR = PERM_YEAR_IN ,
    destination= destination_in ,
    UPDATE_DATE = SYSDATE ,
    UPDATE_USER =  USER_PKG.GET_USER_ID
   WHERE SER = SER_IN  and adopt < 40 ;

  MSG_OUT:=  SQL%ROWCOUNT;

EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'EXIT_PERMISSION_TB_UPDATE '|| SQLERRM;
END EXIT_PERMISSION_TB_UPDATE ;

----------------------------------------------------------------------

PROCEDURE EXIT_PERMISSION_TB_DELETE (
SER_IN  IN EXIT_PERMISSION_TB.SER%TYPE ,
MSG_OUT OUT VARCHAR2) AS
BEGIN
 DELETE  FROM  EXIT_PERMISSION_TB
 WHERE  SER = SER_IN  ;
  MSG_OUT:=  SQL%ROWCOUNT;
EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'EXIT_PERMISSION_TB_DELETE '|| SQLERRM;
END EXIT_PERMISSION_TB_DELETE ;

---------------------------------------------------------------------------

PROCEDURE EXIT_PERMISSION_TB_GET (
SER_IN  IN EXIT_PERMISSION_TB.SER%TYPE ,
 REF_CUR_OUT OUT SYS_REFCURSOR,MSG_OUT OUT VARCHAR2   ) AS
BEGIN
 OPEN REF_CUR_OUT FOR
SELECT  M.* ,
 EMP_PKG.GET_EMP_NAME( M.EMP_NO)  EMP_NO_NAME ,
 TO_CHAR(M.p_exit_time,'HH24:MI') p_exit_time ,
 TO_CHAR(M.p_ret_time,'HH24:MI')  p_ret_time ,
 SETTING_PKG.CONSTANT_DETAILS_TB_GET_NAME(212 ,M.ADOPT)  ADOPT_NAME ,
 SETTING_PKG.CONSTANT_DETAILS_TB_GET_NAME(211 ,M.PERMI_TYPE)  PERMI_TYPE_NAME ,
 USER_PKG.GET_USER_NAME(M.ENTRY_USER)  ENTRY_USER_NAME ,
 SETTING_PKG.GCC_BRANCHES_TB_GET_NAME (M.BRANCH_ID)  BRANCH_ID_NAME ,
 GET_MANAGER_EMAIL(M.EMP_NO) MANAGER_EMAIL
FROM EXIT_PERMISSION_TB  M
 WHERE M.SER = SER_IN  ;
   MSG_OUT:= 1;
EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'EXIT_PERMISSION_TB_GET '|| SQLERRM;
END EXIT_PERMISSION_TB_GET ;

------------------------------------------------------------------------

PROCEDURE EXIT_PERMISSION_TB_GET_ALL (
REF_CUR_OUT OUT SYS_REFCURSOR,MSG_OUT OUT VARCHAR2   )
AS
BEGIN
 OPEN REF_CUR_OUT FOR
SELECT  M.* ,
 EMP_PKG.GET_EMP_NAME( M.EMP_NO)  EMP_NO_NAME ,
 SETTING_PKG.CONSTANT_DETAILS_TB_GET_NAME(1 ,M.ADOPT)  ADOPT_NAME ,
 SETTING_PKG.CONSTANT_DETAILS_TB_GET_NAME(1 ,M.PERMI_TYPE)  PERMI_TYPE_NAME ,
 USER_PKG.GET_USER_NAME(M.ENTRY_USER)  ENTRY_USER_NAME ,
 SETTING_PKG.GCC_BRANCHES_TB_GET_NAME (M.BRANCH_ID)  BRANCH_ID_NAME
FROM EXIT_PERMISSION_TB  M ;
   MSG_OUT:= 1;
EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'EXIT_PERMISSION_TB_GET_ALL '|| SQLERRM;
END EXIT_PERMISSION_TB_GET_ALL ;

-------------------------------------------------------------

PROCEDURE EXIT_PERMISSION_TB_LIST (INSQL IN VARCHAR2 ,
 OFFSET    NUMBER,ROW    NUMBER ,
  REF_CUR_OUT OUT SYS_REFCURSOR,MSG_OUT OUT VARCHAR2  ) AS
 XSQL VARCHAR2(4000);
BEGIN
XSQL:= 'SELECT * FROM (
SELECT  M.* ,
 TO_CHAR(ENTRY_DATE,''DD/MM/YYYY HH24:MI'') ENTRY_DATE_TIME ,
 EMP_PKG.GET_EMP_NAME( M.EMP_NO)  EMP_NO_NAME ,
 TO_CHAR(M.p_exit_time, ''HH24:MI'') p_exit_time_ ,
 TO_CHAR(M.p_ret_time, ''HH24:MI'')  p_ret_time_ ,
 HR_ATTENDANCE_PKG.GET_INTERVAL_MINUTES(p_exit_time , p_ret_time)  MINS ,
 QF_PKG.GET_DAY_NAME_AR(m.P_DATE) DAY_AR ,
 SETTING_PKG.CONSTANT_DETAILS_TB_GET_NAME(212 ,M.ADOPT)  ADOPT_NAME ,
 SETTING_PKG.CONSTANT_DETAILS_TB_GET_NAME(211 ,M.PERMI_TYPE)  PERMI_TYPE_NAME ,
 USER_PKG.GET_USER_NAME(M.ENTRY_USER)  ENTRY_USER_NAME ,
 USER_PKG.GET_USER_NAME(M.ADOPT_USER_20)  ADOPT_USER_20_NAME ,
 SETTING_PKG.GCC_BRANCHES_TB_GET_NAME (M.BRANCH_ID)  BRANCH_ID_NAME ,
ROW_NUMBER() OVER ( ORDER BY  M.SER DESC) RN
FROM EXIT_PERMISSION_TB  M '||INSQL ||' ORDER BY SER DESC )
 WHERE RN BETWEEN '||(OFFSET +1)||' AND '|| ROW ||' ORDER BY RN ';
  OPEN REF_CUR_OUT FOR XSQL;
     MSG_OUT:= 1;
  EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'EXIT_PERMISSION_TB_LIST '|| SQLERRM;
 END  EXIT_PERMISSION_TB_LIST ;

-------------------------------------------------------------

PROCEDURE EXIT_PERMISSION_TB_ADOPT(
SER_IN  IN EXIT_PERMISSION_TB.SER%TYPE ,
ADOPT_IN  IN EXIT_PERMISSION_TB.ADOPT%TYPE ,
permi_type_IN  IN EXIT_PERMISSION_TB.permi_type%TYPE ,
MSG_OUT OUT VARCHAR2)  AS
L_permi_type NUMBER;
L_chk NUMBER;
L_HOURS NUMBER;
L_DAY DATE;
BEGIN

CASE ADOPT_IN

 WHEN  0 THEN
 UPDATE EXIT_PERMISSION_TB SET
 ADOPT  = ADOPT_IN ,
 CANCEL_DATE = SYSDATE ,
 CANCEL_USER = USER_PKG.GET_USER_ID
 WHERE SER = SER_IN and adopt=1 and entry_user= USER_PKG.GET_USER_ID ;
 MSG_OUT:=  SQL%ROWCOUNT;

 WHEN  -20 THEN
 UPDATE EXIT_PERMISSION_TB SET
 ADOPT  = 0 ,
 CANCEL_DATE = SYSDATE ,
 CANCEL_USER = USER_PKG.GET_USER_ID
 WHERE SER = SER_IN and adopt=20 ;
 MSG_OUT:=  SQL%ROWCOUNT;

 WHEN  -30 THEN
 UPDATE EXIT_PERMISSION_TB SET
 ADOPT  = 0 ,
 CANCEL_DATE = SYSDATE ,
 CANCEL_USER = USER_PKG.GET_USER_ID
 WHERE SER = SER_IN and adopt in (30,10) ;
 MSG_OUT:=  SQL%ROWCOUNT;

 WHEN  -40 THEN
 UPDATE EXIT_PERMISSION_TB SET
 ADOPT  = 30
 WHERE SER = SER_IN and adopt=40 ;
 MSG_OUT:=  SQL%ROWCOUNT;

    If MSG_OUT = 1 Then
        SELECT nvl(a.permi_type,0) into L_permi_type FROM EXIT_PERMISSION_TB a where a.ser= SER_IN ;
        If L_permi_type not in (2,3) Then  -- استثناء اذن مهمة عمل وسحب راتب من تجميع ساعات الاذونات
            EXIT_PERMISSION_SUM_TB_TRANS(SER_IN,'-',MSG_OUT);
        END If;
    END If;

 WHEN  10 THEN
 UPDATE EXIT_PERMISSION_TB SET
 ADOPT  = ADOPT_IN
 WHERE SER = SER_IN and adopt=1 and entry_user= USER_PKG.GET_USER_ID ;
 MSG_OUT:=  SQL%ROWCOUNT;

 WHEN  20 THEN
 UPDATE EXIT_PERMISSION_TB SET
 ADOPT  =  case WHEN p_ret_time is not null then 30 else 20 end , --- ADOPT_IN  ,
 permi_type = nvl(permi_type_IN,permi_type) ,
 ADOPT_DATE_20 = SYSDATE  ,
 ADOPT_USER_20 = USER_PKG.GET_USER_ID
 WHERE SER = SER_IN and adopt=10 and emp_no != user_pkg.get_user_emp_no ;
 MSG_OUT:=  SQL%ROWCOUNT;

 WHEN 30 THEN

 -- التأكد ان وقت العودة بعد وقت الخروج
 select update_time(SYSDATE, 5, '-') - a.p_exit_time into L_chk from EXIT_PERMISSION_TB a where a.ser= SER_IN ;

 UPDATE EXIT_PERMISSION_TB SET
 ADOPT  = ADOPT_IN  ,
 p_ret_time= update_time(SYSDATE, 5, '-') ,
 ADOPT_DATE_30 = SYSDATE  ,
 ADOPT_USER_30 = USER_PKG.GET_USER_ID
 WHERE SER = SER_IN  and adopt=20 and L_chk > 0 ;
 MSG_OUT:=  SQL%ROWCOUNT;

 WHEN  40 THEN

 SELECT A.P_DATE INTO L_DAY FROM EXIT_PERMISSION_TB A WHERE A.SER= SER_IN ;
 L_HOURS := HR_ATTENDANCE_PKG.OFF_WORK_HOURS_CNT_FHOURS_ADAY ( HR_ATTENDANCE_PKG.OFF_WORK_HOURS_DETECT_ROW(1, L_DAY  ) ) ;

 IF L_HOURS = -1 THEN
    L_HOURS := 7*60; -- Default
 ELSE
    L_HOURS := L_HOURS*60;
 END IF;

 UPDATE EXIT_PERMISSION_TB SET
 ADOPT = ADOPT_IN  ,
 ADOPT_DATE_40= SYSDATE ,
 ADOPT_USER_40= USER_PKG.GET_USER_ID
 WHERE SER= SER_IN AND ADOPT= 30 AND PERMI_TYPE != 4
 AND P_EXIT_TIME IS NOT NULL AND P_RET_TIME IS NOT NULL
 AND GET_INTERVAL_MINUTES(P_EXIT_TIME, P_RET_TIME) BETWEEN 5 AND L_HOURS ;
 MSG_OUT:=  SQL%ROWCOUNT;

    If MSG_OUT = 1 Then
        SELECT nvl(a.permi_type,0) into L_permi_type FROM EXIT_PERMISSION_TB a where a.ser= SER_IN ;
        If L_permi_type not in (2,3) Then  -- استثناء اذن مهمة عمل وسحب راتب من تجميع ساعات الاذونات
            EXIT_PERMISSION_SUM_TB_TRANS(SER_IN,'+',MSG_OUT);
        END If;
    END If;

 ELSE
  MSG_OUT:= 'ERROR';
 END CASE;
 EXCEPTION
 WHEN OTHERS THEN
 MSG_OUT :=  'HR_ATTENDANCE_PKG'||'EXIT_PERMISSION_TB_ADOPT '|| SQLERRM;
 END  EXIT_PERMISSION_TB_ADOPT ;

--------------------------------------------------------------------------------------

PROCEDURE EXIT_PERMISSION_SUM_TB_INSERT (
EMP_NO_IN  IN EXIT_PERMISSION_SUM_TB.EMP_NO%TYPE ,
PERM_YEAR_IN  IN EXIT_PERMISSION_SUM_TB.PERM_YEAR%TYPE ,
SUM_MINUTES_IN  IN EXIT_PERMISSION_SUM_TB.SUM_MINUTES%TYPE ,
SUM_DAYS_IN  IN EXIT_PERMISSION_SUM_TB.SUM_DAYS%TYPE ,
MSG_OUT OUT VARCHAR2) AS
SEQ_VAL NUMBER ;
BEGIN
SEQ_VAL  := EXIT_PERMISSION_SUM_TB_SEQ.NEXTVAL;
INSERT INTO  EXIT_PERMISSION_SUM_TB(
SER ,EMP_NO ,PERM_YEAR ,SUM_MINUTES ,SUM_DAYS ,BRANCH_ID ) VALUES
(SEQ_VAL   ,EMP_NO_IN ,PERM_YEAR_IN ,SUM_MINUTES_IN ,SUM_DAYS_IN ,USER_PKG.GET_USER_BRANCH_NO ) ;
MSG_OUT:= SEQ_VAL ;
EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'EXIT_PERMISSION_SUM_TB_INSERT '|| SQLERRM;
END EXIT_PERMISSION_SUM_TB_INSERT ;

-------------------------------------------------------------------------------------------------

PROCEDURE EXIT_PERMISSION_SUM_TB_UPDATE (
SER_IN  IN EXIT_PERMISSION_SUM_TB.SER%TYPE ,
EMP_NO_IN  IN EXIT_PERMISSION_SUM_TB.EMP_NO%TYPE ,
PERM_YEAR_IN  IN EXIT_PERMISSION_SUM_TB.PERM_YEAR%TYPE ,
SUM_MINUTES_IN  IN EXIT_PERMISSION_SUM_TB.SUM_MINUTES%TYPE ,
SUM_DAYS_IN  IN EXIT_PERMISSION_SUM_TB.SUM_DAYS%TYPE ,
MSG_OUT OUT VARCHAR2) AS
BEGIN

UPDATE EXIT_PERMISSION_SUM_TB SET
    EMP_NO = EMP_NO_IN   ,
    PERM_YEAR = PERM_YEAR_IN   ,
    SUM_MINUTES = SUM_MINUTES_IN   ,
    SUM_DAYS = SUM_DAYS_IN
   WHERE SER = SER_IN  ;
  MSG_OUT:=  SQL%ROWCOUNT;
EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'EXIT_PERMISSION_SUM_TB_UPDATE '|| SQLERRM;
END EXIT_PERMISSION_SUM_TB_UPDATE ;

----------------------------------------------------------------------

PROCEDURE EXIT_PERMISSION_SUM_TB_DELETE (
SER_IN  IN EXIT_PERMISSION_SUM_TB.SER%TYPE ,
MSG_OUT OUT VARCHAR2) AS
BEGIN
 DELETE  FROM  EXIT_PERMISSION_SUM_TB
 WHERE  SER = SER_IN  ;
  MSG_OUT:=  SQL%ROWCOUNT;
EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'EXIT_PERMISSION_SUM_TB_DELETE '|| SQLERRM;
END EXIT_PERMISSION_SUM_TB_DELETE ;

---------------------------------------------------------------------------

PROCEDURE EXIT_PERMISSION_SUM_TB_GET (
SER_IN  IN EXIT_PERMISSION_SUM_TB.SER%TYPE ,
 REF_CUR_OUT OUT SYS_REFCURSOR,MSG_OUT OUT VARCHAR2   ) AS
BEGIN
 OPEN REF_CUR_OUT FOR
SELECT  M.* ,
 EMP_PKG.GET_EMP_NAME( M.EMP_NO)  EMP_NO_NAME ,
 SETTING_PKG.GCC_BRANCHES_TB_GET_NAME (M.BRANCH_ID)  BRANCH_ID_NAME
FROM EXIT_PERMISSION_SUM_TB  M
 WHERE M.SER = SER_IN  ;
   MSG_OUT:= 1;
EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'EXIT_PERMISSION_SUM_TB_GET '|| SQLERRM;
END EXIT_PERMISSION_SUM_TB_GET ;

-------------------------------------------------------------

PROCEDURE EXIT_PERMISSION_SUM_TB_LIST (INSQL IN VARCHAR2 ,
 OFFSET    NUMBER,ROW    NUMBER ,
  REF_CUR_OUT OUT SYS_REFCURSOR,MSG_OUT OUT VARCHAR2  ) AS
 XSQL VARCHAR2(4000);
BEGIN
XSQL:= 'SELECT * FROM (
SELECT  M.* ,
 EMP_PKG.GET_EMP_NAME( M.EMP_NO)  EMP_NO_NAME ,
 SETTING_PKG.GCC_BRANCHES_TB_GET_NAME (M.BRANCH_ID)  BRANCH_ID_NAME ,
ROW_NUMBER() OVER ( ORDER BY  M.SER DESC) RN
FROM EXIT_PERMISSION_SUM_TB  M '||INSQL||
'ORDER BY SER DESC )
 WHERE RN BETWEEN '||(OFFSET +1)||' AND '|| ROW ||' ORDER BY RN ';
  OPEN REF_CUR_OUT FOR XSQL;
     MSG_OUT:= 1;
  EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'EXIT_PERMISSION_SUM_TB_LIST '|| SQLERRM;
 END  EXIT_PERMISSION_SUM_TB_LIST ;

 --------------------------------------------------------------

PROCEDURE EXIT_PERMISSION_SUM_TB_TRANS (
SER_IN  IN EXIT_PERMISSION_TB.SER%TYPE ,
ACTION  IN VARCHAR2 ,
MSG_OUT OUT VARCHAR2  ) AS
R EXIT_PERMISSION_TB%ROWTYPE;
THE_COUNT NUMBER ;
THE_MINUTE NUMBER ;
EXIT_INTERVAL NUMBER ;
L_MIN_DAY NUMBER ;
BEGIN

L_MIN_DAY:= 420; -- old 360

SELECT  M.* INTO R FROM EXIT_PERMISSION_TB M
WHERE M.SER = SER_IN ;

EXIT_INTERVAL:= GET_INTERVAL_MINUTES( R.P_EXIT_TIME , R.P_RET_TIME);

SELECT COUNT(0) INTO THE_COUNT
FROM  EXIT_PERMISSION_SUM_TB S
WHERE S.EMP_NO = R.EMP_NO
AND   S.PERM_YEAR = R.PERM_YEAR ;

-- اضافة مدة للاذن لتجميع الاذونات
IF ACTION = '+' THEN

    IF    THE_COUNT = 0 THEN

        INSERT INTO EXIT_PERMISSION_SUM_TB
          (SER, EMP_NO, PERM_YEAR, SUM_MINUTES, SUM_DAYS, SUM_DAYS_VACATION, BRANCH_ID ) VALUES
          ( EXIT_PERMISSION_SUM_TB_SEQ.NEXTVAL , R.EMP_NO , R.PERM_YEAR , DECODE(EXIT_INTERVAL,L_MIN_DAY,0,EXIT_INTERVAL) , DECODE(EXIT_INTERVAL,L_MIN_DAY,1,0) , 0, R.BRANCH_ID ) ;

        MSG_OUT:=  SQL%ROWCOUNT;

         IF MSG_OUT != 1 THEN
            MSG_OUT :='ORA-ERROR: EXIT_PERMISSION_SUM_TB_TRANS: INSERT ';
         END IF;

    ELSIF THE_COUNT = 1 THEN

         UPDATE EXIT_PERMISSION_SUM_TB S
           SET SUM_MINUTES = NVL(SUM_MINUTES,0) + EXIT_INTERVAL
         WHERE S.EMP_NO = R.EMP_NO
         AND   S.PERM_YEAR = R.PERM_YEAR ;

         MSG_OUT:=  SQL%ROWCOUNT;

         IF MSG_OUT != 1 THEN
            MSG_OUT :='ORA-ERROR: EXIT_PERMISSION_SUM_TB_TRANS: EXIT_INTERVAL 1';
         END IF;

        SELECT SUM_MINUTES INTO THE_MINUTE
        FROM  EXIT_PERMISSION_SUM_TB S
        WHERE S.EMP_NO = R.EMP_NO
        AND   S.PERM_YEAR = R.PERM_YEAR ;

        IF MSG_OUT=1 and NVL(THE_MINUTE,0) >= L_MIN_DAY THEN
           UPDATE EXIT_PERMISSION_SUM_TB S
           SET SUM_MINUTES = SUM_MINUTES - L_MIN_DAY ,
               SUM_DAYS = NVL(SUM_DAYS,0) + 1
           WHERE S.EMP_NO = R.EMP_NO
           AND   S.PERM_YEAR = R.PERM_YEAR ;

           MSG_OUT:=  SQL%ROWCOUNT;

             IF MSG_OUT != 1 THEN
                MSG_OUT :='ORA-ERROR: EXIT_PERMISSION_SUM_TB_TRANS: SUM_MINUTES ';
             END IF;

        END IF;

    ELSE
      MSG_OUT:='ORA-ERROR: EXIT_PERMISSION_SUM_TB_TRANS: + THE_COUNT='||THE_COUNT ;
    END IF;


-- خصم مدة الاذن من تجميع الاذونات
ELSIF ACTION = '-' THEN

    IF  THE_COUNT = 1 THEN

        SELECT NVL(SUM_MINUTES,0) INTO THE_MINUTE
        FROM  EXIT_PERMISSION_SUM_TB S
        WHERE S.EMP_NO = R.EMP_NO
        AND   S.PERM_YEAR = R.PERM_YEAR ;

        IF THE_MINUTE >= EXIT_INTERVAL THEN

             UPDATE EXIT_PERMISSION_SUM_TB S
               SET S.SUM_MINUTES = S.SUM_MINUTES - EXIT_INTERVAL
             WHERE S.EMP_NO = R.EMP_NO
             AND   S.PERM_YEAR = R.PERM_YEAR
             and  (S.SUM_MINUTES - EXIT_INTERVAL) >= 0 ;

             MSG_OUT:=  SQL%ROWCOUNT;

             IF MSG_OUT != 1 THEN
                MSG_OUT :='ORA-ERROR: EXIT_PERMISSION_SUM_TB_TRANS: EXIT_INTERVAL 2 ';
             END IF;

        ELSE
             UPDATE EXIT_PERMISSION_SUM_TB S
               SET s.sum_days = s.sum_days - 1 ,
                   S.SUM_MINUTES = S.SUM_MINUTES + L_MIN_DAY - EXIT_INTERVAL
             WHERE S.EMP_NO = R.EMP_NO
             AND   S.PERM_YEAR = R.PERM_YEAR
             and  (s.sum_days - 1) >= 0
             and  (S.SUM_MINUTES + L_MIN_DAY - EXIT_INTERVAL) >= 0 ;

             MSG_OUT:=  SQL%ROWCOUNT;

             IF MSG_OUT != 1 THEN
                MSG_OUT :='ORA-ERROR: EXIT_PERMISSION_SUM_TB_TRANS: EXIT_INTERVAL 3 ';
             END IF;


        END IF;

    ELSE
      MSG_OUT:='ORA-ERROR: EXIT_PERMISSION_SUM_TB_TRANS: - THE_COUNT='||THE_COUNT ;
    END IF;


END IF;

EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'EXIT_PERMISSION_SUM_TB_TRANS '|| SQLERRM;
END EXIT_PERMISSION_SUM_TB_TRANS ;

-------------------------------------------------------------

PROCEDURE EXIT_PERMISSION_TB_BALANCE (
EMP_NO_IN  IN EXIT_PERMISSION_TB.EMP_NO%TYPE ,
P_DATE_IN  IN EXIT_PERMISSION_TB.P_DATE%TYPE ,
REF_CUR_OUT OUT SYS_REFCURSOR,MSG_OUT OUT VARCHAR2  ) AS
BEGIN
 OPEN REF_CUR_OUT FOR

SELECT TO_CHAR(TRUNC(P_DATE_IN,'mm'), 'MM/YYYY') month_ , count(0) cnt ,
sum(HR_ATTENDANCE_PKG.GET_INTERVAL_MINUTES(a.p_exit_time , a.p_ret_time)) total
from gfc_hr.exit_permission_tb  a
where a.permi_type not in (2,3)
and a.adopt >= 10
and a.emp_no= EMP_NO_IN
and TRUNC(a.p_date,'mm') = TRUNC(P_DATE_IN,'mm') ;

   MSG_OUT:= 1;
EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'EXIT_PERMISSION_TB_BALANCE '|| SQLERRM;
END EXIT_PERMISSION_TB_BALANCE ;

-------------------------------------------------------------
 /*
PROCEDURE EXIT_PERMISSION_SUM_TB_ADOPT(
SER_IN  IN EXIT_PERMISSION_SUM_TB.SER%TYPE ,
ADOPT_IN  NUMBER  , MSG_OUT OUT VARCHAR2)  AS
BEGIN
  IF  ADOPT_IN = 2 THEN
      UPDATE  EXIT_PERMISSION_SUM_TB  SET
      ADOPT = ADOPT_IN ,
      ADOPT_USER = USER_PKG.GET_USER_ID  ,
      ADOPT_DATE = SYSDATE
      WHERE  SER = SER_IN  AND ADOPT = ADOPT_IN - 1  ;
  END IF;
  MSG_OUT:=  SQL%ROWCOUNT;
  EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'EXIT_PERMISSION_SUM_TB_ADOPT '|| SQLERRM;
 END  EXIT_PERMISSION_SUM_TB_ADOPT ;
*/
--------------------------------------------------------------------------------------

PROCEDURE VACATION_REQUEST_TB_INSERT (
EMP_NO_IN  IN VACATION_REQUEST_TB.EMP_NO%TYPE ,
VAC_TYPE_IN  IN VACATION_REQUEST_TB.VAC_TYPE%TYPE ,
VAC_DATE_IN  IN VACATION_REQUEST_TB.VAC_DATE%TYPE ,
VAC_END_DATE_IN  IN VACATION_REQUEST_TB.VAC_END_DATE%TYPE ,
VAC_DURATION_IN  IN VACATION_REQUEST_TB.VAC_DURATION%TYPE ,
ADD_IN_VAC_IN  IN VACATION_REQUEST_TB.ADD_IN_VAC%TYPE ,
THE_REASON_IN  IN VACATION_REQUEST_TB.THE_REASON%TYPE ,
ACTING_OFFICER_IN  IN VACATION_REQUEST_TB.ACTING_OFFICER%TYPE ,
RET_DATE_IN  IN VACATION_REQUEST_TB.RET_DATE%TYPE ,
NOTES_IN  IN VACATION_REQUEST_TB.NOTES%TYPE ,
vac_year_IN  IN VACATION_REQUEST_TB.vac_year%TYPE ,
MSG_OUT OUT VARCHAR2) AS
SEQ_VAL NUMBER ;
BEGIN
SEQ_VAL  := VACATION_REQUEST_TB_SEQ.NEXTVAL;
INSERT INTO  VACATION_REQUEST_TB(
SER ,EMP_NO ,VAC_TYPE ,VAC_DATE ,VAC_END_DATE ,VAC_DURATION ,ADD_IN_VAC ,THE_REASON ,ACTING_OFFICER ,RET_DATE ,NOTES ,ADOPT ,ENTRY_USER ,ENTRY_DATE ,BRANCH_ID , vac_year ) VALUES
(SEQ_VAL   ,EMP_NO_IN ,VAC_TYPE_IN ,VAC_DATE_IN ,VAC_END_DATE_IN , (VAC_END_DATE_IN-VAC_DATE_IN+1) ,ADD_IN_VAC_IN ,THE_REASON_IN ,ACTING_OFFICER_IN ,RET_DATE_IN ,NOTES_IN ,1 ,
 USER_PKG.GET_USER_ID  , SYSDATE  , USER_PKG.GET_USER_BRANCH_NO , vac_year_IN ) ;
MSG_OUT:= SEQ_VAL ;
EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'VACATION_REQUEST_TB_INSERT '|| SQLERRM;
END VACATION_REQUEST_TB_INSERT ;

-------------------------------------------------------------------------------------------------

PROCEDURE VACATION_REQUEST_TB_UPDATE (
SER_IN  IN VACATION_REQUEST_TB.SER%TYPE ,
EMP_NO_IN  IN VACATION_REQUEST_TB.EMP_NO%TYPE ,
VAC_TYPE_IN  IN VACATION_REQUEST_TB.VAC_TYPE%TYPE ,
VAC_DATE_IN  IN VACATION_REQUEST_TB.VAC_DATE%TYPE ,
VAC_END_DATE_IN  IN VACATION_REQUEST_TB.VAC_END_DATE%TYPE ,
VAC_DURATION_IN  IN VACATION_REQUEST_TB.VAC_DURATION%TYPE ,
ADD_IN_VAC_IN  IN VACATION_REQUEST_TB.ADD_IN_VAC%TYPE ,
THE_REASON_IN  IN VACATION_REQUEST_TB.THE_REASON%TYPE ,
ACTING_OFFICER_IN  IN VACATION_REQUEST_TB.ACTING_OFFICER%TYPE ,
RET_DATE_IN  IN VACATION_REQUEST_TB.RET_DATE%TYPE ,
NOTES_IN  IN VACATION_REQUEST_TB.NOTES%TYPE ,
vac_year_IN  IN VACATION_REQUEST_TB.vac_year%TYPE ,
MSG_OUT OUT VARCHAR2) AS
BEGIN

UPDATE VACATION_REQUEST_TB SET
    EMP_NO = EMP_NO_IN   ,
    VAC_TYPE = VAC_TYPE_IN   ,
    VAC_DATE = VAC_DATE_IN   ,
    VAC_END_DATE = VAC_END_DATE_IN   ,
    VAC_DURATION = (VAC_END_DATE_IN-VAC_DATE_IN+1)   ,
    ADD_IN_VAC = ADD_IN_VAC_IN   ,
    THE_REASON = THE_REASON_IN   ,
    ACTING_OFFICER = ACTING_OFFICER_IN   ,
    RET_DATE = RET_DATE_IN   ,
    NOTES = NOTES_IN ,
    vac_year = vac_year_IN ,
    UPDATE_DATE = SYSDATE ,
    UPDATE_USER =  USER_PKG.GET_USER_ID
   WHERE SER = SER_IN  and adopt < 40 ;
  MSG_OUT:=  SQL%ROWCOUNT;
EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'VACATION_REQUEST_TB_UPDATE '|| SQLERRM;
END VACATION_REQUEST_TB_UPDATE ;

----------------------------------------------------------------------

PROCEDURE VACATION_REQUEST_TB_DELETE (
SER_IN  IN VACATION_REQUEST_TB.SER%TYPE ,
MSG_OUT OUT VARCHAR2) AS
BEGIN
 DELETE  FROM  VACATION_REQUEST_TB
 WHERE  SER = SER_IN  ;
  MSG_OUT:=  SQL%ROWCOUNT;
EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'VACATION_REQUEST_TB_DELETE '|| SQLERRM;
END VACATION_REQUEST_TB_DELETE ;

---------------------------------------------------------------------------

PROCEDURE VACATION_REQUEST_TB_GET (
SER_IN  IN VACATION_REQUEST_TB.SER%TYPE ,
 REF_CUR_OUT OUT SYS_REFCURSOR,MSG_OUT OUT VARCHAR2   ) AS
BEGIN
 OPEN REF_CUR_OUT FOR
SELECT  M.* ,
 EMP_PKG.GET_EMP_NAME( M.EMP_NO)  EMP_NO_NAME ,
 SETTING_PKG.CONSTANT_DETAILS_TB_GET_NAME(214 ,M.VAC_TYPE)  VAC_TYPE_NAME ,
 SETTING_PKG.CONSTANT_DETAILS_TB_GET_NAME(215 ,M.ADOPT)  ADOPT_NAME ,
 USER_PKG.GET_USER_NAME(M.ENTRY_USER)  ENTRY_USER_NAME ,
 SETTING_PKG.GCC_BRANCHES_TB_GET_NAME (M.BRANCH_ID)  BRANCH_ID_NAME ,
 GET_MANAGER_EMAIL(M.EMP_NO) MANAGER_EMAIL
FROM VACATION_REQUEST_TB  M
 WHERE M.SER = SER_IN  ;
   MSG_OUT:= 1;
EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'VACATION_REQUEST_TB_GET '|| SQLERRM;
END VACATION_REQUEST_TB_GET ;

------------------------------------------------------------------------

PROCEDURE VACATION_REQUEST_TB_GET_ALL (
REF_CUR_OUT OUT SYS_REFCURSOR,MSG_OUT OUT VARCHAR2   )
AS
BEGIN
 OPEN REF_CUR_OUT FOR
SELECT  M.* ,
 EMP_PKG.GET_EMP_NAME( M.EMP_NO)  EMP_NO_NAME ,
 SETTING_PKG.CONSTANT_DETAILS_TB_GET_NAME(214 ,M.VAC_TYPE)  VAC_TYPE_NAME ,
 SETTING_PKG.CONSTANT_DETAILS_TB_GET_NAME(215 ,M.ADOPT)  ADOPT_NAME ,
 USER_PKG.GET_USER_NAME(M.ENTRY_USER)  ENTRY_USER_NAME ,
 SETTING_PKG.GCC_BRANCHES_TB_GET_NAME (M.BRANCH_ID)  BRANCH_ID_NAME
FROM VACATION_REQUEST_TB  M ;
   MSG_OUT:= 1;
EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'VACATION_REQUEST_TB_GET_ALL '|| SQLERRM;
END VACATION_REQUEST_TB_GET_ALL ;

-------------------------------------------------------------

PROCEDURE VACATION_REQUEST_TB_LIST (INSQL IN VARCHAR2 ,
 OFFSET    NUMBER,ROW    NUMBER ,
  REF_CUR_OUT OUT SYS_REFCURSOR,MSG_OUT OUT VARCHAR2  ) AS
 XSQL VARCHAR2(4000);
BEGIN
XSQL:= 'SELECT * FROM (
SELECT  M.* ,
 TO_CHAR(ENTRY_DATE,''DD/MM/YYYY HH24:MI'') ENTRY_DATE_TIME ,
 EMP_PKG.GET_EMP_NAME( M.EMP_NO)  EMP_NO_NAME ,
 USER_PKG.GET_USER_NAME(M.ADOPT_USER_20)  ADOPT_USER_20_NAME ,
 SETTING_PKG.CONSTANT_DETAILS_TB_GET_NAME(214 ,M.VAC_TYPE)  VAC_TYPE_NAME ,
 SETTING_PKG.CONSTANT_DETAILS_TB_GET_NAME(215 ,M.ADOPT)  ADOPT_NAME ,
 USER_PKG.GET_USER_NAME(M.ENTRY_USER)  ENTRY_USER_NAME ,
 SETTING_PKG.GCC_BRANCHES_TB_GET_NAME (M.BRANCH_ID)  BRANCH_ID_NAME ,
ROW_NUMBER() OVER ( ORDER BY  M.SER DESC) RN
FROM VACATION_REQUEST_TB  M '||INSQL||
'ORDER BY SER DESC )
 WHERE RN BETWEEN '||(OFFSET +1)||' AND '|| ROW ||' ORDER BY RN ';
  OPEN REF_CUR_OUT FOR XSQL;
     MSG_OUT:= 1;
  EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'VACATION_REQUEST_TB_LIST '|| SQLERRM;
 END  VACATION_REQUEST_TB_LIST ;

 -------------------------------------------------------------------------------

 PROCEDURE VACATION_REQUEST_TB_ADOPT(
SER_IN  IN VACATION_REQUEST_TB.SER%TYPE ,
ADOPT_IN  IN VACATION_REQUEST_TB.ADOPT%TYPE ,
refusal_note_IN  IN VACATION_REQUEST_TB.refusal_note%TYPE ,
MSG_OUT OUT VARCHAR2)  AS
L_chk  NUMBER;
L_CAN_ADOPT NUMBER;
L_TYPE_2 NUMBER;
L_DUPLICATE NUMBER;
R_VACATION   VACATION_REQUEST_TB%ROWTYPE;
BEGIN

CASE ADOPT_IN

 WHEN  0 THEN
 UPDATE VACATION_REQUEST_TB SET
 ADOPT  = ADOPT_IN ,
 CANCEL_DATE = SYSDATE ,
 CANCEL_USER = USER_PKG.GET_USER_ID
 WHERE SER = SER_IN and adopt=1 and entry_user= USER_PKG.GET_USER_ID ;
 MSG_OUT:=  SQL%ROWCOUNT;

 WHEN  -10 THEN
 UPDATE VACATION_REQUEST_TB SET
 ADOPT  = 1
 WHERE SER = SER_IN and adopt=10 and entry_user= USER_PKG.GET_USER_ID ;
 MSG_OUT:=  SQL%ROWCOUNT;

 WHEN  -20 THEN
 UPDATE VACATION_REQUEST_TB SET
 ADOPT  = 0 ,
 CANCEL_DATE = SYSDATE ,
 CANCEL_USER = USER_PKG.GET_USER_ID
 WHERE SER = SER_IN and adopt=20 ;
 MSG_OUT:=  SQL%ROWCOUNT;

 WHEN  -30 THEN
 UPDATE VACATION_REQUEST_TB SET
 ADOPT  = 0 ,
 CANCEL_DATE = SYSDATE ,
 CANCEL_USER = USER_PKG.GET_USER_ID
 WHERE SER = SER_IN and adopt in (30,10) ;
 MSG_OUT:=  SQL%ROWCOUNT;

 WHEN  -40 THEN
 UPDATE VACATION_REQUEST_TB SET
 ADOPT  =  DECODE(vac_type,1,30,2,30,17,30, 1) -- OLD- 17/12/2018  DECODE(vac_type,3,1,30)
 WHERE SER = SER_IN and adopt=40 ;
 MSG_OUT:=  SQL%ROWCOUNT;

 WHEN  -1 THEN
 UPDATE VACATION_REQUEST_TB SET
 ADOPT  = ADOPT_IN ,
 refusal_note = refusal_note_in ,
 CANCEL_DATE = SYSDATE ,
 CANCEL_USER = USER_PKG.GET_USER_ID
 WHERE SER = SER_IN and adopt=10 ;
 MSG_OUT:=  SQL%ROWCOUNT;

 WHEN  10 THEN

---- فحص الرصيد قبل اعتماد الاجازة -- check balance
 L_CAN_ADOPT := 0;

 select * into R_VACATION
 from vacation_request_tb a
 where a.ser= SER_IN ;

IF    GET_VACATION_TYPE_CONSTANT( R_VACATION.vac_type ) = 0 THEN -- لا تخصم رصيد
    L_CAN_ADOPT := 1;

ELSIF GET_VACATION_TYPE_CONSTANT( R_VACATION.vac_type ) = 3 THEN -- مرضية
    L_CAN_ADOPT := 1;

ELSIF GET_VACATION_TYPE_CONSTANT( R_VACATION.vac_type ) = 2 THEN -- طارئة
    IF VACATION_EMERGENCY_LEFT(R_VACATION.emp_no, R_VACATION.vac_year) >= R_VACATION.vac_duration THEN
        L_CAN_ADOPT := 1;
    END IF;

ELSIF GET_VACATION_TYPE_CONSTANT( R_VACATION.vac_type ) = 1 THEN -- عادية
    IF VACATION_NORMAL_LEFT(R_VACATION.emp_no, R_VACATION.vac_year) >= R_VACATION.vac_duration THEN
        L_CAN_ADOPT := 1;
    END IF;

END IF;
----- check balance


---- فحص للتأكد من استنفاذ رصيد الاجازات العادية قبل الطارئة -- check Emergency - Added 02/12/2019
L_TYPE_2 :=0;

IF ( R_VACATION.vac_type =2 AND VACATION_NORMAL_LEFT(R_VACATION.emp_no, R_VACATION.vac_year) = 0 ) OR R_VACATION.vac_type !=2 THEN
    L_TYPE_2 :=1;
END IF;
----- check Emergency


---- فحص تكرار الاجازة قبل اعتماد الاجازة -- check duplicate

L_DUPLICATE :=0;

SELECT COUNT(0) INTO L_chk
from gfc_hr.vacation_request_tb  a
where a.emp_no= R_VACATION.emp_no
and a.adopt >= 10
and a.ser != R_VACATION.ser
and ( R_VACATION.vac_date     BETWEEN a.vac_date and a.vac_end_date
  OR  R_VACATION.vac_end_date BETWEEN a.vac_date and a.vac_end_date ) ;

 IF L_chk = 0 THEN
    L_DUPLICATE := 1;
 END IF;

----- check duplicate

 IF L_CAN_ADOPT = 1 AND L_DUPLICATE = 1 AND L_TYPE_2 = 1 THEN

    -- ادخال تاريخ العودة تلقائيا حسب الشروط  -  insert ret_date
    IF R_VACATION.vac_duration = 1  and  R_VACATION.ret_date is null
    and  GET_CNT_EMP_ATTENDANCE_STATUS(R_VACATION.emp_no, (R_VACATION.vac_end_date+1), 1 ) >= 1
    and  TRUNC(R_VACATION.entry_date)  =  (R_VACATION.vac_end_date+1)  THEN

        UPDATE VACATION_REQUEST_TB SET
        ADOPT  = ADOPT_IN , ret_date = (R_VACATION.vac_end_date+1)
        WHERE SER = SER_IN and adopt=1 and entry_user= USER_PKG.GET_USER_ID ;
        MSG_OUT:=  SQL%ROWCOUNT;

    ELSE

        UPDATE VACATION_REQUEST_TB SET
        ADOPT  = ADOPT_IN
        WHERE SER = SER_IN and adopt=1 and entry_user= USER_PKG.GET_USER_ID ;
        MSG_OUT:=  SQL%ROWCOUNT;

    END IF;


 ELSIF L_CAN_ADOPT = 0 THEN
    MSG_OUT:= 'NO_BALANCE - رصيد الاجازات غير كافي';

 ELSIF L_TYPE_2 = 0 THEN
    MSG_OUT:= 'EMERGENCY - يجب استنفاذ رصيد الاجازات العادية قبل الطارئة';

 ELSIF L_DUPLICATE = 0 THEN
    MSG_OUT:= 'DUPLICATE -  الاجازة مكررة او هناك تعارض مع تاريخ اجازة اخرى';

 ELSE
    MSG_OUT:= 'ERROR - خطأ غير معروف';

 END IF;


 WHEN  20 THEN
 UPDATE VACATION_REQUEST_TB SET
 ADOPT  = case WHEN RET_DATE is not null then 30 else 20 end  ,
 ADOPT_DATE_20 = SYSDATE  ,
 ADOPT_USER_20 = USER_PKG.GET_USER_ID
 WHERE SER = SER_IN and adopt=10 and emp_no != user_pkg.get_user_emp_no ;
 MSG_OUT:=  SQL%ROWCOUNT;

 WHEN 30 THEN

 -- التأكد ان تاريخ العودة بعد تاريخ نهاية الاجازة
 select TRUNC(SYSDATE) - a.vac_end_date into L_chk from VACATION_REQUEST_TB a where a.ser= SER_IN ;

 UPDATE VACATION_REQUEST_TB SET
 ADOPT  = ADOPT_IN  ,
 RET_DATE = TRUNC(SYSDATE) ,
 ADOPT_DATE_30 = SYSDATE  ,
 ADOPT_USER_30 = USER_PKG.GET_USER_ID
 WHERE SER = SER_IN  and adopt=20 and L_chk > 0 ;
 MSG_OUT:=  SQL%ROWCOUNT;

 WHEN  40 THEN

---- فحص الرصيد قبل اعتماد الاجازة -- check balance
 L_CAN_ADOPT := 0;

 select * into R_VACATION
 from vacation_request_tb a
 where a.ser= SER_IN ;

IF  R_VACATION.vac_type IN (1,2,17) THEN
    L_CAN_ADOPT := 1;

ELSIF    GET_VACATION_TYPE_CONSTANT( R_VACATION.vac_type ) = 0 THEN -- لا تخصم رصيد
    L_CAN_ADOPT := 1;

ELSIF GET_VACATION_TYPE_CONSTANT( R_VACATION.vac_type ) = 3 THEN -- مرضية
    L_CAN_ADOPT := 1;

ELSIF GET_VACATION_TYPE_CONSTANT( R_VACATION.vac_type ) = 2 THEN -- طارئة
    IF VACATION_EMERGENCY_LEFT(R_VACATION.emp_no, R_VACATION.vac_year) >= R_VACATION.vac_duration THEN
        L_CAN_ADOPT := 1;
    END IF;

ELSIF GET_VACATION_TYPE_CONSTANT( R_VACATION.vac_type ) = 1 THEN -- عادية
    IF VACATION_NORMAL_LEFT(R_VACATION.emp_no, R_VACATION.vac_year) >= R_VACATION.vac_duration THEN
        L_CAN_ADOPT := 1;
    END IF;

END IF;
----- check balance


---- فحص تكرار الاجازة قبل اعتماد الاجازة -- check duplicate

L_DUPLICATE :=0;

SELECT COUNT(0) INTO L_chk
from gfc_hr.vacation_request_tb  a
where a.emp_no= R_VACATION.emp_no
and a.adopt >= 10
and a.ser != R_VACATION.ser
and ( R_VACATION.vac_date     BETWEEN a.vac_date and a.vac_end_date
  OR  R_VACATION.vac_end_date BETWEEN a.vac_date and a.vac_end_date ) ;

 IF L_chk = 0 THEN
    L_DUPLICATE := 1;
 END IF;

----- check duplicate

  IF L_CAN_ADOPT = 1 AND L_DUPLICATE = 1 THEN

     UPDATE VACATION_REQUEST_TB SET
     ADOPT  = ADOPT_IN  ,
     ADOPT_DATE_40 = SYSDATE  ,
     ADOPT_USER_40 = USER_PKG.GET_USER_ID
     WHERE SER = SER_IN and nvl(ret_date,'1/1/1000') > vac_end_date
     and ( (adopt=1 and vac_type not in (1,2,17) ) or ( vac_type in (1,2,17) and adopt=30 ) ) ; -- OLD- 17/12/2018  ( adopt=30 or (vac_type=3 and adopt=1) )
     MSG_OUT:=  SQL%ROWCOUNT;

  ELSIF L_CAN_ADOPT = 0 THEN
    MSG_OUT:= 'NO_BALANCE - رصيد الاجازات غير كافي';
  ELSIF L_DUPLICATE = 0 THEN
    MSG_OUT:= 'DUPLICATE -  الاجازة مكررة او هناك تعارض مع تاريخ اجازة اخرى';
  ELSE
    MSG_OUT:= 'ERROR - خطأ غير معروف';
  END IF;


 ELSE
  MSG_OUT:= 'ERROR';
 END CASE;
 EXCEPTION
 WHEN OTHERS THEN
 MSG_OUT :=  'HR_ATTENDANCE_PKG'||'VACATION_REQUEST_TB_ADOPT '|| SQLERRM;
 END  VACATION_REQUEST_TB_ADOPT ;

-----------------------------------------------------------------------------------

FUNCTION VACATION_REQUEST_SUM_DAY(
EMP_NO_IN  IN VACATION_REQUEST_TB.EMP_NO%TYPE ,
VAC_TYPE_IN  IN VACATION_REQUEST_TB.VAC_TYPE%TYPE ,
VAC_YEAR_IN IN VACATION_REQUEST_TB.VAC_YEAR%TYPE ) RETURN  NUMBER IS
RES  NUMBER;
OLD_SUM_DAY NUMBER ;
BEGIN

SELECT SUM(VAC_DURATION) INTO RES  FROM VACATION_REQUEST_TB
WHERE VAC_TYPE in ( select a.con_no from gfc.constant_details_tb a  where a.tb_no= 214  and a.account_id = VAC_TYPE_IN )
-- decode(VAC_TYPE,2,2,3,3, 1) = VAC_TYPE_IN --- OLD 11/10/2018
AND   EMP_NO = EMP_NO_IN
AND   VAC_YEAR = VAC_YEAR_IN
AND   ADOPT >= 10 ;

SELECT SUM(DAY_NO) INTO OLD_SUM_DAY FROM DATA.VACANCIES T
WHERE  FROM_DATE BETWEEN '01/01/2018' and  '31/08/2018'
AND EMP_NO = EMP_NO_IN and VAC_YEAR_IN = 2018 -- and t.is_vacancy= 1
AND VACANCY_TYPE = VAC_TYPE_IN ;


RETURN NVL(RES,0) + NVL(OLD_SUM_DAY,0) ;

EXCEPTION
WHEN NO_DATA_FOUND  THEN
             RETURN 0;
WHEN OTHERS  THEN
             RETURN 0;
END  VACATION_REQUEST_SUM_DAY ;

------------------------------------------------------------------------------------

FUNCTION EMP_VACANCIES_DAYS_TOTAL(
EMP_NO_IN  IN DATA.EMP_VACANCIES_DAYS.EMP_NO%TYPE ,
THE_YEAR_IN  IN DATA.EMP_VACANCIES_DAYS.THE_YEAR%TYPE ) RETURN  NUMBER IS
RES  NUMBER;
BEGIN

SELECT DAYES INTO RES FROM DATA.EMP_VACANCIES_DAYS T
WHERE THE_YEAR = THE_YEAR_IN
AND   EMP_NO = EMP_NO_IN ;

RETURN NVL(RES,0);

EXCEPTION
WHEN NO_DATA_FOUND  THEN
             RETURN 0;
WHEN OTHERS  THEN
             RETURN 0;
END  EMP_VACANCIES_DAYS_TOTAL ;

-----------------------------------------------------------------------------------

FUNCTION EMP_VACANCIES_UN_DAY_TOTAL(
EMP_NO_IN  IN VACATION_REQUEST_TB.EMP_NO%TYPE ,
THE_YEAR_IN  IN DATA.EMP_VACANCIES_DAYS.THE_YEAR%TYPE ) RETURN  NUMBER IS
RES  NUMBER;
BEGIN

SELECT UNNORMAL_DAYS INTO RES FROM DATA.EMP_VACANCIES_DAYS T
WHERE THE_YEAR = THE_YEAR_IN
AND   EMP_NO = EMP_NO_IN ;

RETURN NVL(RES,0);

/* OLD : 202206
SELECT EMP_TYPE INTO RES  FROM DATA.EMPLOYEES
WHERE NO = EMP_NO_IN ;

IF RES IN (1,10 ) THEN
   RETURN  10 ;
ELSE
   RETURN 0 ;
END IF;
*/

EXCEPTION
WHEN NO_DATA_FOUND  THEN
             RETURN 0;
WHEN OTHERS  THEN
             RETURN 0;
END  EMP_VACANCIES_UN_DAY_TOTAL ;


-----------------------------------------------------------------------------------

FUNCTION NORMAL_EXIT_USED_SUM(
EMP_NO_IN   IN VACATION_REQUEST_TB.EMP_NO%TYPE ,
VAC_YEAR_IN IN VACATION_REQUEST_TB.VAC_YEAR%TYPE ) RETURN  NUMBER IS
RES  NUMBER;
BEGIN

select a.SUM_DAYS INTO RES
from exit_permission_sum_tb a
where a.emp_no= EMP_NO_IN
and a.perm_year= VAC_YEAR_IN ;

RETURN NVL(RES,0);

EXCEPTION
WHEN NO_DATA_FOUND  THEN
             RETURN 0;
WHEN OTHERS  THEN
             RETURN 0;
END  NORMAL_EXIT_USED_SUM ;

-----------------------------------------------------------------------------------

FUNCTION VACATION_NORMAL_LEFT(
EMP_NO_IN   IN VACATION_REQUEST_TB.EMP_NO%TYPE ,
VAC_YEAR_IN IN VACATION_REQUEST_TB.VAC_YEAR%TYPE ) RETURN  NUMBER IS
BEGIN

RETURN EMP_VACANCIES_DAYS_TOTAL(EMP_NO_IN, VAC_YEAR_IN) - VACATION_REQUEST_SUM_DAY(EMP_NO_IN, 1, VAC_YEAR_IN ) - VACATION_NORMAL_EXIT (EMP_NO_IN, VAC_YEAR_IN) + VACATION_BALANCE_TRANS_SUM(EMP_NO_IN, 1 ,VAC_YEAR_IN) ;

EXCEPTION
WHEN NO_DATA_FOUND  THEN
             RETURN 0;
WHEN OTHERS  THEN
             RETURN 0;
END  VACATION_NORMAL_LEFT ;

---------------------------------------------------------------------------------

FUNCTION VACATION_EMERGENCY_LEFT (
EMP_NO_IN   IN VACATION_REQUEST_TB.EMP_NO%TYPE ,
VAC_YEAR_IN IN VACATION_REQUEST_TB.VAC_YEAR%TYPE ) RETURN  NUMBER IS
BEGIN

RETURN EMP_VACANCIES_UN_DAY_TOTAL(EMP_NO_IN, VAC_YEAR_IN) - VACATION_REQUEST_SUM_DAY(EMP_NO_IN, 2, VAC_YEAR_IN ) - VACATION_EMERGENCY_EXIT (EMP_NO_IN, VAC_YEAR_IN)  ;

EXCEPTION
WHEN NO_DATA_FOUND  THEN
             RETURN 0;
WHEN OTHERS  THEN
             RETURN 0;
END  VACATION_EMERGENCY_LEFT ;

---------------------------------------------------------------------------------

FUNCTION VACATION_NORMAL_EXIT (
EMP_NO_IN   IN VACATION_REQUEST_TB.EMP_NO%TYPE ,
VAC_YEAR_IN IN VACATION_REQUEST_TB.VAC_YEAR%TYPE ) RETURN  NUMBER IS
RES  NUMBER;
BEGIN

select least( EMP_VACANCIES_DAYS_TOTAL(EMP_NO_IN, VAC_YEAR_IN) - VACATION_REQUEST_SUM_DAY(EMP_NO_IN, 1, VAC_YEAR_IN) + VACATION_BALANCE_TRANS_SUM(EMP_NO_IN, 1 ,VAC_YEAR_IN) , NORMAL_EXIT_USED_SUM(EMP_NO_IN, VAC_YEAR_IN)  ) INTO RES
from DUAL;

RETURN NVL(RES,0);

EXCEPTION
WHEN NO_DATA_FOUND  THEN
             RETURN 0;
WHEN OTHERS  THEN
             RETURN 0;
END  VACATION_NORMAL_EXIT ;

------------------------------------------------------------------------------------

FUNCTION VACATION_EMERGENCY_EXIT  (
EMP_NO_IN   IN VACATION_REQUEST_TB.EMP_NO%TYPE ,
VAC_YEAR_IN IN VACATION_REQUEST_TB.VAC_YEAR%TYPE ) RETURN  NUMBER IS
BEGIN

RETURN NVL( NORMAL_EXIT_USED_SUM(EMP_NO_IN, VAC_YEAR_IN) - VACATION_NORMAL_EXIT(EMP_NO_IN, VAC_YEAR_IN), 0) ;

EXCEPTION
WHEN NO_DATA_FOUND  THEN
             RETURN 0;
WHEN OTHERS  THEN
             RETURN 0;
END  VACATION_EMERGENCY_EXIT  ;

---------------------------------------------------------------------------

-- الدالة غير جاهزة لانواع الاجازات الاخرى
FUNCTION VACATION_BALANCE_TRANS_SUM(
EMP_NO_IN IN VACATION_BALANCE_TRANS_TB.EMP_NO%TYPE,
VAC_TYPE_IN IN VACATION_BALANCE_TRANS_TB.VAC_TYPE%TYPE,
YEAR_IN IN VACATION_BALANCE_TRANS_TB.YEAR_FROM%TYPE )
RETURN  NUMBER IS
RES_TO  NUMBER;
RES_FROM  NUMBER;
BEGIN

select sum(a.balance_val) INTO RES_TO
from gfc_hr.vacation_balance_trans_tb   a
where a.emp_no= EMP_NO_IN
and a.vac_type= VAC_TYPE_IN
and a.year_to = YEAR_IN
and a.adopt = 2 ;

select sum(a.balance_val) INTO RES_FROM
from gfc_hr.vacation_balance_trans_tb   a
where a.emp_no= EMP_NO_IN
and a.vac_type= VAC_TYPE_IN
and a.year_from = YEAR_IN
and a.adopt = 2 ;

RETURN NVL(RES_TO,0) - NVL(RES_FROM,0) ;

EXCEPTION
WHEN NO_DATA_FOUND  THEN
             RETURN 0;
WHEN OTHERS  THEN
             RETURN 0;
END  VACATION_BALANCE_TRANS_SUM ;

------------------------------------------------------------------------------------

PROCEDURE VACATION_REQUEST_TB_BALANCE (
EMP_NO_IN  IN NUMBER , YEAR_IN  IN NUMBER ,
REF_CUR_OUT OUT SYS_REFCURSOR,MSG_OUT OUT VARCHAR2   ) AS
L_THE_YEAR NUMBER;
BEGIN

L_THE_YEAR:= NVL(YEAR_IN, TO_CHAR(SYSDATE,'YYYY') );

 OPEN REF_CUR_OUT FOR
 SELECT L_THE_YEAR BALANCE_YEAR,
 EMP_VACANCIES_DAYS_TOTAL(EMP_NO_IN, L_THE_YEAR) NORMAL_TOTAL ,
 VACATION_REQUEST_SUM_DAY(EMP_NO_IN, 1, L_THE_YEAR ) NORMAL_USED  ,
 VACATION_NORMAL_LEFT(EMP_NO_IN, L_THE_YEAR)  NORMAL_LEFT,

 VACATION_BALANCE_TRANS_SUM(EMP_NO_IN, 1 ,L_THE_YEAR) NORMAL_TRANS,

 EMP_VACANCIES_UN_DAY_TOTAL(EMP_NO_IN, L_THE_YEAR)  EMERGENCY_TOTAL ,
 VACATION_REQUEST_SUM_DAY(EMP_NO_IN, 2, L_THE_YEAR)   EMERGENCY_USED ,
 VACATION_EMERGENCY_LEFT (EMP_NO_IN, L_THE_YEAR )  EMERGENCY_LEFT ,

 VACATION_REQUEST_SUM_DAY(EMP_NO_IN, 3, L_THE_YEAR )  SICK_USED ,
 VACATION_NORMAL_EXIT (EMP_NO_IN, L_THE_YEAR)  NORMAL_EXIT_USED ,
 VACATION_EMERGENCY_EXIT (EMP_NO_IN, L_THE_YEAR)  EMERGENCY_EXIT_USED

 FROM DUAL ;

 MSG_OUT:= 1;
EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'VACATION_REQUEST_TB_BALANCE '|| SQLERRM;
END VACATION_REQUEST_TB_BALANCE ;

-----------------------------------------------------------------------------------------------

PROCEDURE EXIT_PERMISSION_GET_TB (INSQL IN VARCHAR2 ,
 OFFSET    NUMBER, ROW    NUMBER ,
  REF_CUR_OUT OUT SYS_REFCURSOR, MSG_OUT OUT VARCHAR2  ) AS
 XSQL VARCHAR2(8000);
BEGIN
XSQL:= 'SELECT * FROM (
SELECT  M.* ,
 TO_CHAR(ENTRY_DATE,''DD/MM/YYYY HH24:MI'') ENTRY_DATE_TIME ,
 EMP_PKG.GET_EMP_NAME( M.EMP_NO)  EMP_NO_NAME ,
 TO_CHAR(M.p_exit_time, ''HH24:MI'') p_exit_time_ ,
 TO_CHAR(M.p_ret_time, ''HH24:MI'')  p_ret_time_ ,
 HR_ATTENDANCE_PKG.GET_INTERVAL_MINUTES(p_exit_time , p_ret_time)  MINS ,
 QF_PKG.GET_DAY_NAME_AR(m.P_DATE) DAY_AR ,
 SETTING_PKG.CONSTANT_DETAILS_TB_GET_NAME(212 ,M.ADOPT)  ADOPT_NAME ,
 SETTING_PKG.CONSTANT_DETAILS_TB_GET_NAME(211 ,M.PERMI_TYPE)  PERMI_TYPE_NAME ,
 USER_PKG.GET_USER_NAME(M.ENTRY_USER)  ENTRY_USER_NAME ,
 USER_PKG.GET_USER_NAME(M.ADOPT_USER_20)  ADOPT_USER_20_NAME ,
 SETTING_PKG.GCC_BRANCHES_TB_GET_NAME (M.BRANCH_ID)  BRANCH_ID_NAME ,
 ROW_NUMBER() OVER ( ORDER BY  M.SER DESC) RN
       FROM EXIT_PERMISSION_TB  M '||INSQL ||' ORDER BY SER DESC )
 WHERE RN BETWEEN '||(OFFSET +1)||' AND '|| ROW ||' ORDER BY RN ';
  OPEN REF_CUR_OUT FOR INSQL;
     MSG_OUT:= 1;
  EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'EXIT_PERMISSION_GET_TB '|| SQLERRM;
 END  EXIT_PERMISSION_GET_TB ;

-------------------------------------------------------------------------------------------------

PROCEDURE VACATION_BALANCE_TRANS_INSERT (
EMP_NO_IN IN VACATION_BALANCE_TRANS_TB.EMP_NO%TYPE,
YEAR_FROM_IN IN VACATION_BALANCE_TRANS_TB.YEAR_FROM%TYPE,
YEAR_TO_IN IN VACATION_BALANCE_TRANS_TB.YEAR_TO%TYPE,
BALANCE_VAL_IN IN VACATION_BALANCE_TRANS_TB.BALANCE_VAL%TYPE,
MSG_OUT OUT VARCHAR2 ) AS
SEQ_VAL NUMBER ;
BEGIN
    SEQ_VAL := VACATION_BALANCE_TRANS_TB_SEQ.NEXTVAL;
    INSERT INTO VACATION_BALANCE_TRANS_TB
    (SER, EMP_NO, VAC_TYPE, YEAR_FROM, YEAR_TO, BALANCE_VAL, ENTRY_USER, ENTRY_DATE, ADOPT)
    VALUES
    (SEQ_VAL, EMP_NO_IN, 1, YEAR_FROM_IN, YEAR_TO_IN, BALANCE_VAL_IN, USER_PKG.GET_USER_ID, SYSDATE, 1) ;
MSG_OUT:= SEQ_VAL ;
EXCEPTION
WHEN OTHERS THEN
MSG_OUT := 'HR_ATTENDANCE_PKG.'||'VACATION_BALANCE_TRANS_INSERT '|| SQLERRM;
END VACATION_BALANCE_TRANS_INSERT;

-------------------------------------------------------------------------------------------------

PROCEDURE VACATION_BALANCE_TRANS_UPDATE (
SER_IN IN VACATION_BALANCE_TRANS_TB.SER%TYPE,
EMP_NO_IN IN VACATION_BALANCE_TRANS_TB.EMP_NO%TYPE,
YEAR_FROM_IN IN VACATION_BALANCE_TRANS_TB.YEAR_FROM%TYPE,
YEAR_TO_IN IN VACATION_BALANCE_TRANS_TB.YEAR_TO%TYPE,
BALANCE_VAL_IN IN VACATION_BALANCE_TRANS_TB.BALANCE_VAL%TYPE,
MSG_OUT OUT VARCHAR2 ) AS
BEGIN
    UPDATE VACATION_BALANCE_TRANS_TB SET
    EMP_NO = EMP_NO_IN ,
    YEAR_FROM = YEAR_FROM_IN ,
    YEAR_TO = YEAR_TO_IN ,
    BALANCE_VAL = BALANCE_VAL_IN
    WHERE SER = SER_IN and ADOPT = 1 ;
MSG_OUT:= SQL%ROWCOUNT ;
EXCEPTION
WHEN OTHERS THEN
MSG_OUT := 'HR_ATTENDANCE_PKG.'||'VACATION_BALANCE_TRANS_UPDATE '|| SQLERRM;
END VACATION_BALANCE_TRANS_UPDATE;

-------------------------------------------------------------------------------------------------

PROCEDURE VACATION_BALANCE_TRANS_GET (
SER_IN  IN VACATION_BALANCE_TRANS_TB.SER%TYPE ,
REF_CUR_OUT OUT SYS_REFCURSOR, MSG_OUT OUT VARCHAR2 ) AS
BEGIN
 OPEN REF_CUR_OUT FOR
   SELECT  M.* ,  EMP_PKG.GET_EMP_NAME( M.EMP_NO)  EMP_NO_NAME
   FROM VACATION_BALANCE_TRANS_TB  M
   WHERE M.SER = SER_IN ;
MSG_OUT:= 1;
EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG.'||'VACATION_BALANCE_TRANS_GET '|| SQLERRM;
END VACATION_BALANCE_TRANS_GET ;

-------------------------------------------------------------------------------------------------

PROCEDURE VACATION_BALANCE_TRANS_LIST (INSQL IN VARCHAR2 ,
 OFFSET   NUMBER, ROW   NUMBER ,
  REF_CUR_OUT OUT SYS_REFCURSOR,MSG_OUT OUT VARCHAR2  ) AS
 XSQL VARCHAR2(4000);
BEGIN
XSQL:= 'SELECT * FROM (
SELECT  M.* ,
 TO_CHAR(ENTRY_DATE,''DD/MM/YYYY HH24:MI'') ENTRY_DATE_TIME ,
 EMP_PKG.GET_EMP_NAME( M.EMP_NO)  EMP_NO_NAME ,
 SETTING_PKG.CONSTANT_DETAILS_TB_GET_NAME(312 ,M.ADOPT)  ADOPT_NAME ,
 USER_PKG.GET_USER_NAME(M.ENTRY_USER)  ENTRY_USER_NAME ,
 USER_PKG.GET_USER_NAME(M.ADOPT_USER)  ADOPT_USER_NAME ,
ROW_NUMBER() OVER ( ORDER BY  M.SER DESC) RN
FROM VACATION_BALANCE_TRANS_TB  M '||INSQL ||' ORDER BY SER DESC )
 WHERE RN BETWEEN '||(OFFSET +1)||' AND '|| ROW ||' ORDER BY RN ';
  OPEN REF_CUR_OUT FOR XSQL;
     MSG_OUT:= 1;
  EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG.'||'VACATION_BALANCE_TRANS_LIST '|| SQLERRM;
 END  VACATION_BALANCE_TRANS_LIST ;

 -------------------------------------------------------------------------------------------------

PROCEDURE VACATION_BALANCE_TRANS_ADOPT(
SER_IN  IN VACATION_BALANCE_TRANS_TB.SER%TYPE ,
ADOPT_IN  IN VACATION_BALANCE_TRANS_TB.ADOPT%TYPE ,
MSG_OUT OUT VARCHAR2)  AS
R_VACATION_TRANS   VACATION_BALANCE_TRANS_TB%ROWTYPE;
BEGIN

CASE ADOPT_IN

 WHEN 2 THEN

 SELECT * into R_VACATION_TRANS
 from VACATION_BALANCE_TRANS_TB a
 where a.ser= SER_IN ;

 IF R_VACATION_TRANS.year_from +1 = R_VACATION_TRANS.year_to
 AND VACATION_NORMAL_LEFT(R_VACATION_TRANS.emp_no, R_VACATION_TRANS.year_from) >= R_VACATION_TRANS.balance_val THEN

     UPDATE VACATION_BALANCE_TRANS_TB SET
     ADOPT  = ADOPT_IN ,
     ADOPT_DATE = SYSDATE  ,
     ADOPT_USER = USER_PKG.GET_USER_ID
     WHERE SER = SER_IN and ADOPT=1  ;
    MSG_OUT:=  SQL%ROWCOUNT;

 ELSE
    MSG_OUT:= 'ERROR  year OR balance - يجب ان يكون النقل للسنة التالية ويجب ان يكون رصيد الاجازات كافي';
 END IF;

 ELSE
  MSG_OUT:= 'ERROR';
 END CASE;

 EXCEPTION
 WHEN OTHERS THEN
 MSG_OUT :=  'HR_ATTENDANCE_PKG.'||'VACATION_BALANCE_TRANS_ADOPT '|| SQLERRM;
 END  VACATION_BALANCE_TRANS_ADOPT ;

-------------------------------------------------------------------------------------------------------

/* before ARWA update 24/09/2019
PROCEDURE ASSIGNING_WORK_TB_INSERT (
EMP_NO_IN  IN ASSIGNING_WORK_TB.EMP_NO%TYPE ,
ASS_START_TIME_IN IN VARCHAR2 ,
ASS_END_TIME_IN   IN VARCHAR2 ,
ASS_START_DATE_IN IN DATE ,
ASS_END_DATE_IN   IN DATE ,
EXPECTED_DURATION_IN  IN ASSIGNING_WORK_TB.EXPECTED_DURATION%TYPE ,
CALC_DURATION_IN  IN ASSIGNING_WORK_TB.CALC_DURATION%TYPE ,
WORK_REQUIRED_IN  IN ASSIGNING_WORK_TB.WORK_REQUIRED%TYPE ,
NOTES_IN  IN ASSIGNING_WORK_TB.NOTES%TYPE ,
food_no_IN  IN ASSIGNING_WORK_TB.food_no%TYPE ,
MSG_OUT OUT VARCHAR2) AS
SEQ_VAL NUMBER ;
V_START DATE;
V_END DATE;
V_HOURS NUMBER ;
BEGIN

if ASS_START_TIME_IN is null then
    V_START:= '';
ELSE
    V_START:= TO_DATE(ASS_START_DATE_IN||ASS_START_TIME_IN,'DD/MM/YYYY HH24:MI');
    V_START:= update_time(V_START, 5, '-');
END if;

if ASS_END_TIME_IN is null then
    V_END:= '';
ELSE
    V_END:= TO_DATE(ASS_END_DATE_IN||ASS_END_TIME_IN,'DD/MM/YYYY HH24:MI');
    V_END:= update_time(V_END, 5, '+');
END if;

IF V_END IS NOT NULL  THEN
    V_HOURS :=  ROUND( (HR_ATTENDANCE_PKG.GET_INTERVAL_MINUTES(V_START , V_END) / 60), 2) ;
END if;

SEQ_VAL  := ASSIGNING_WORK_TB_SEQ.NEXTVAL;
INSERT INTO  ASSIGNING_WORK_TB(
SER ,EMP_NO  ,ASS_START_TIME ,ASS_END_TIME ,EXPECTED_DURATION ,ASS_DURATION , CALC_DURATION, WORK_REQUIRED ,NOTES , food_no,
ADOPT ,ENTRY_USER ,ENTRY_DATE ,BRANCH_ID , emp_work )
VALUES
(SEQ_VAL  ,EMP_NO_IN , V_START , V_END ,EXPECTED_DURATION_IN , V_HOURS , NVL(CALC_DURATION_IN,V_HOURS) , WORK_REQUIRED_IN ,NOTES_IN , food_no_IN,
1 , USER_PKG.GET_USER_ID  , SYSDATE , USER_PKG.GET_USER_BRANCH_NO , emp_pkg.GET_EMP_WORK_NO( EMP_NO_IN) ) ;
MSG_OUT:= SEQ_VAL ;
EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'ASSIGNING_WORK_TB_INSERT '|| SQLERRM;
END ASSIGNING_WORK_TB_INSERT ;

-------------------------------------------------------------------------------------------------

PROCEDURE ASSIGNING_WORK_TB_UPDATE (
SER_IN  IN ASSIGNING_WORK_TB.SER%TYPE ,
EMP_NO_IN  IN ASSIGNING_WORK_TB.EMP_NO%TYPE ,
ASS_START_TIME_IN IN VARCHAR2 ,
ASS_END_TIME_IN   IN VARCHAR2 ,
ASS_START_DATE_IN IN DATE ,
ASS_END_DATE_IN   IN DATE ,
EXPECTED_DURATION_IN  IN ASSIGNING_WORK_TB.EXPECTED_DURATION%TYPE ,
CALC_DURATION_IN  IN ASSIGNING_WORK_TB.CALC_DURATION%TYPE ,
WORK_REQUIRED_IN  IN ASSIGNING_WORK_TB.WORK_REQUIRED%TYPE ,
NOTES_IN  IN ASSIGNING_WORK_TB.NOTES%TYPE ,
food_no_IN  IN ASSIGNING_WORK_TB.food_no%TYPE ,
MSG_OUT OUT VARCHAR2) AS
V_START DATE;
V_END DATE;
V_HOURS NUMBER;
BEGIN

if ASS_START_TIME_IN is null then
    V_START:= '';
ELSE
    V_START:= TO_DATE(ASS_START_DATE_IN||ASS_START_TIME_IN,'DD/MM/YYYY HH24:MI');
    V_START:= update_time(V_START, 5, '-');
END if;

if ASS_END_TIME_IN is null then
    V_END:= '';
ELSE
    V_END:= TO_DATE(ASS_END_DATE_IN||ASS_END_TIME_IN,'DD/MM/YYYY HH24:MI');
    V_END:= update_time(V_END, 5, '+');
END if;

IF V_END IS NOT NULL  THEN
    V_HOURS :=  ROUND( (HR_ATTENDANCE_PKG.GET_INTERVAL_MINUTES(V_START , V_END) / 60), 2) ;
END if;

UPDATE ASSIGNING_WORK_TB SET
    EMP_NO = EMP_NO_IN   ,
    ASS_START_TIME = V_START   ,
    ASS_END_TIME = V_END   ,
    EXPECTED_DURATION = EXPECTED_DURATION_IN   ,
    CALC_DURATION =  NVL(CALC_DURATION_IN,V_HOURS) ,
    ASS_DURATION = V_HOURS ,
    WORK_REQUIRED = WORK_REQUIRED_IN ,
    NOTES = NOTES_IN,
    food_no = food_no_IN,
    emp_work = emp_pkg.GET_EMP_WORK_NO( EMP_NO_IN) ,
    UPDATE_DATE = SYSDATE ,
    UPDATE_USER =  USER_PKG.GET_USER_ID
   WHERE SER = SER_IN  and adopt < 40 ;

  MSG_OUT:=  SQL%ROWCOUNT;
EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'ASSIGNING_WORK_TB_UPDATE '|| SQLERRM;
END ASSIGNING_WORK_TB_UPDATE ;

*/

----------------------------------------------------------------------

PROCEDURE ASSIGNING_WORK_TB_INSERT (
EMP_NO_IN  IN ASSIGNING_WORK_TB.EMP_NO%TYPE ,
ASS_START_TIME_IN IN VARCHAR2 ,
ASS_END_TIME_IN   IN VARCHAR2 ,
ASS_START_DATE_IN IN DATE ,
ASS_END_DATE_IN   IN DATE ,
EXPECTED_DURATION_IN  IN ASSIGNING_WORK_TB.EXPECTED_DURATION%TYPE ,
CALC_DURATION_IN  IN ASSIGNING_WORK_TB.CALC_DURATION%TYPE ,
WORK_REQUIRED_IN  IN ASSIGNING_WORK_TB.WORK_REQUIRED%TYPE ,
NOTES_IN  IN ASSIGNING_WORK_TB.NOTES%TYPE ,
food_no_IN  IN ASSIGNING_WORK_TB.food_no%TYPE ,
start_gps_IN  IN ASSIGNING_WORK_TB.start_gps%TYPE ,
finished_gps_IN  IN ASSIGNING_WORK_TB.finished_gps%TYPE ,
EXPECTED_LEAVE_TIME_IN  IN ASSIGNING_WORK_TB.EXPECTED_LEAVE_TIME%TYPE ,
EXPECTED_ARRIVAL_TIME_IN  IN ASSIGNING_WORK_TB.EXPECTED_ARRIVAL_TIME%TYPE ,
FROM_ADDRESS_IN  IN ASSIGNING_WORK_TB.FROM_ADDRESS%TYPE ,
TO_ADDRESS_IN  IN ASSIGNING_WORK_TB.TO_ADDRESS%TYPE ,
CAR_REQUEST_IN  IN ASSIGNING_WORK_TB.CAR_REQUEST%TYPE ,
MSG_OUT OUT VARCHAR2) AS
SEQ_VAL NUMBER ;
V_START DATE;
V_END DATE;
V_HOURS NUMBER ;
V_OPEN_ASSIGNING_WORK NUMBER ;
BEGIN

if ASS_START_TIME_IN is null then
    V_START:= '';
ELSE
    V_START:= TO_DATE(ASS_START_DATE_IN||ASS_START_TIME_IN,'DD/MM/YYYY HH24:MI');
    V_START:= update_time(V_START, 5, '-');
END if;

if ASS_END_TIME_IN is null then
    V_END:= '';
ELSE
    V_END:= TO_DATE(ASS_END_DATE_IN||ASS_END_TIME_IN,'DD/MM/YYYY HH24:MI');
    V_END:= update_time(V_END, 5, '+');
END if;

IF V_END IS NOT NULL  THEN
    V_HOURS :=  ROUND( (HR_ATTENDANCE_PKG.GET_INTERVAL_MINUTES(V_START , V_END) / 60), 2) ;
END if;


SELECT S.OPEN_ASSIGNING_WORK INTO V_OPEN_ASSIGNING_WORK
FROM GFC_HR.HR_EMPS_STRUCTURE_TB S WHERE S.EMPLOYEE_NO= EMP_NO_IN ;

IF V_OPEN_ASSIGNING_WORK = 1 OR SETTING_PKG.USER_HAVE_ACCESS_MENU (USER_PKG.GET_USER_ID, 'hr_attendance/assigning_work/adopt_40') = 1  THEN

    SEQ_VAL  := ASSIGNING_WORK_TB_SEQ.NEXTVAL;
    INSERT INTO  ASSIGNING_WORK_TB(
    SER ,EMP_NO  ,ASS_START_TIME ,ASS_END_TIME ,EXPECTED_DURATION ,ASS_DURATION , CALC_DURATION, WORK_REQUIRED , NOTES , food_no,
    start_gps,finished_gps,EXPECTED_LEAVE_TIME,EXPECTED_ARRIVAL_TIME,FROM_ADDRESS,TO_ADDRESS,CAR_REQUEST,
    ADOPT ,ENTRY_USER ,ENTRY_DATE ,BRANCH_ID , emp_work)
    VALUES
    (SEQ_VAL  ,EMP_NO_IN , V_START , V_END ,EXPECTED_DURATION_IN , V_HOURS , NVL(CALC_DURATION_IN,V_HOURS) , WORK_REQUIRED_IN ,NOTES_IN , food_no_IN,
    start_gps_IN,finished_gps_IN,EXPECTED_LEAVE_TIME_IN,EXPECTED_ARRIVAL_TIME_IN,FROM_ADDRESS_IN,TO_ADDRESS_IN,CAR_REQUEST_IN,
    1 , USER_PKG.GET_USER_ID  , SYSDATE , USER_PKG.GET_USER_BRANCH_NO , emp_pkg.GET_EMP_WORK_NO( EMP_NO_IN) ) ;
    MSG_OUT:= SEQ_VAL ;

ELSE
    MSG_OUT:= 'لا يمكن ادخال تكليف عمل للموظف المحدد، يرجى مراجعة الشؤون الادارية للسماح له بادخال تكليف عمل' ;
END IF;


EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'ASSIGNING_WORK_TB_INSERT '|| SQLERRM;
END ASSIGNING_WORK_TB_INSERT ;

-------------------------------------------------------------------------------------------------

PROCEDURE ASSIGNING_WORK_TB_UPDATE (
SER_IN  IN ASSIGNING_WORK_TB.SER%TYPE ,
EMP_NO_IN  IN ASSIGNING_WORK_TB.EMP_NO%TYPE ,
ASS_START_TIME_IN IN VARCHAR2 ,
ASS_END_TIME_IN   IN VARCHAR2 ,
ASS_START_DATE_IN IN DATE ,
ASS_END_DATE_IN   IN DATE ,
EXPECTED_DURATION_IN  IN ASSIGNING_WORK_TB.EXPECTED_DURATION%TYPE ,
CALC_DURATION_IN  IN ASSIGNING_WORK_TB.CALC_DURATION%TYPE ,
WORK_REQUIRED_IN  IN ASSIGNING_WORK_TB.WORK_REQUIRED%TYPE ,
NOTES_IN  IN ASSIGNING_WORK_TB.NOTES%TYPE ,
food_no_IN  IN ASSIGNING_WORK_TB.food_no%TYPE ,
start_gps_IN  IN ASSIGNING_WORK_TB.start_gps%TYPE ,
finished_gps_IN  IN ASSIGNING_WORK_TB.finished_gps%TYPE ,
EXPECTED_LEAVE_TIME_IN  IN ASSIGNING_WORK_TB.EXPECTED_LEAVE_TIME%TYPE ,
EXPECTED_ARRIVAL_TIME_IN  IN ASSIGNING_WORK_TB.EXPECTED_ARRIVAL_TIME%TYPE ,
FROM_ADDRESS_IN  IN ASSIGNING_WORK_TB.FROM_ADDRESS%TYPE ,
TO_ADDRESS_IN  IN ASSIGNING_WORK_TB.TO_ADDRESS%TYPE ,
CAR_REQUEST_IN  IN ASSIGNING_WORK_TB.CAR_REQUEST%TYPE ,
MSG_OUT OUT VARCHAR2) AS
V_START DATE;
V_END DATE;
V_HOURS NUMBER;
V_OPEN_ASSIGNING_WORK NUMBER ;
BEGIN

if ASS_START_TIME_IN is null then
    V_START:= '';
ELSE
    V_START:= TO_DATE(ASS_START_DATE_IN||ASS_START_TIME_IN,'DD/MM/YYYY HH24:MI');
    V_START:= update_time(V_START, 5, '-');
END if;

if ASS_END_TIME_IN is null then
    V_END:= '';
ELSE
    V_END:= TO_DATE(ASS_END_DATE_IN||ASS_END_TIME_IN,'DD/MM/YYYY HH24:MI');
    V_END:= update_time(V_END, 5, '+');
END if;

IF V_END IS NOT NULL  THEN
    V_HOURS :=  ROUND( (HR_ATTENDANCE_PKG.GET_INTERVAL_MINUTES(V_START , V_END) / 60), 2) ;
END if;


SELECT S.OPEN_ASSIGNING_WORK INTO V_OPEN_ASSIGNING_WORK
FROM GFC_HR.HR_EMPS_STRUCTURE_TB S WHERE S.EMPLOYEE_NO= EMP_NO_IN ;

IF V_OPEN_ASSIGNING_WORK = 1 OR SETTING_PKG.USER_HAVE_ACCESS_MENU (USER_PKG.GET_USER_ID, 'hr_attendance/assigning_work/adopt_40') = 1  THEN

 UPDATE ASSIGNING_WORK_TB SET
    EMP_NO = EMP_NO_IN   ,
    ASS_START_TIME = V_START   ,
    ASS_END_TIME = V_END   ,
    EXPECTED_DURATION = EXPECTED_DURATION_IN   ,
    CALC_DURATION =  NVL(CALC_DURATION_IN,V_HOURS) ,
    ASS_DURATION = V_HOURS ,
    WORK_REQUIRED = WORK_REQUIRED_IN ,
    NOTES = NOTES_IN,
    food_no = food_no_IN,
    start_gps = start_gps_IN,
    finished_gps = finished_gps_IN,
    EXPECTED_LEAVE_TIME = EXPECTED_LEAVE_TIME_IN,
    EXPECTED_ARRIVAL_TIME = EXPECTED_ARRIVAL_TIME_IN,
    FROM_ADDRESS = FROM_ADDRESS_IN,
    TO_ADDRESS = TO_ADDRESS_IN,
    CAR_REQUEST = CAR_REQUEST_IN,
    emp_work = emp_pkg.GET_EMP_WORK_NO( EMP_NO_IN) ,
    UPDATE_DATE = SYSDATE ,
    UPDATE_USER =  USER_PKG.GET_USER_ID
   WHERE SER = SER_IN  and adopt < 40 ;

   MSG_OUT:=  SQL%ROWCOUNT;
ELSE
    MSG_OUT:= 'لا يمكن ادخال تكليف عمل للموظف المحدد، يرجى مراجعة الشؤون الادارية للسماح له بادخال تكليف عمل' ;
END IF;

EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'ASSIGNING_WORK_TB_UPDATE '|| SQLERRM;
END ASSIGNING_WORK_TB_UPDATE ;

---------------------------------------------------------------------

PROCEDURE ASSIGNING_WORK_TB_UPDATE_REQ (
SER_IN  IN varchar2 ,
CAR_ID_IN  IN CARS_MOVMENTS_TB.CAR_ID%TYPE ,
DRIVER_ID_IN  IN CARS_MOVMENTS_TB.DRIVER_ID%TYPE ,
MOVMENT_TYPE_IN  IN CARS_MOVMENTS_TB.MOVMENT_TYPE%TYPE ,
NOTES_IN  IN CARS_MOVMENTS_TB.NOTES%TYPE ,
ENTRY_USER_IN  IN CARS_MOVMENTS_TB.ENTRY_USER%TYPE ,
CAR_OWNER_IN  IN CARS_MOVMENTS_TB.CAR_OWNER%TYPE ,
MSG_OUT OUT VARCHAR2)  AS


COUNT_REQ NUMBER ;
     BEGIN
         UPDATE   ASSIGNING_WORK_TB
         SET  ASSIGN_DRIVER = 0
         WHERE SER in (
 select x from
 (  select regexp_substr(SER_IN,'[^,]+', 2, level) x from dual
connect by regexp_substr(SER_IN, '[^,]+', 2, level) is not null )
)
and adopt < 40;

-------------
FOR i in (select trunc(ASS_START_TIME) ASS_START_TIME
 from ( select regexp_substr(SER_IN,'[^,]+', 2, level) x from dual
    connect by regexp_substr(SER_IN, '[^,]+', 2, level) is not null
   ), assigning_work_tb  where x = ser
  GROUP BY trunc(ASS_START_TIME))
  LOOP
  COUNT_REQ:=CARS_MOVMENTS_TB_SEQ.NEXTVAL;
  INSERT INTO CARS_MOVMENTS_TB
  (SER,CAR_ID, DRIVER_ID,MOVMENT_TYPE, NOTES,ENTRY_USER,ENTRY_DATE,CAR_OWNER,THE_DATE)
  VALUES
  (COUNT_REQ,CAR_ID_IN,DRIVER_ID_IN,MOVMENT_TYPE_IN,NOTES_IN,ENTRY_USER_IN,SYSDATE,
  CAR_OWNER_IN, i.ASS_START_TIME);


INSERT INTO CARS_MOVMENTS_DET_TB
(SER,CAR_MOV_ID, EXPECTED_LEAVE_TIME,EXPECTED_ARRIVAL_TIME,FROM_ADDRESS
,TO_ADDRESS,PREDEFINE_START_GPS,PREDEFINE_FINISHED_GPS)
select CARS_MOVMENTS_DET_TB_SEQ.NEXTVAL, COUNT_REQ,
TO_DATE(to_char(ASS_START_TIME,'DD/MM/YYYY ')||EXPECTED_LEAVE_TIME,'DD/MM/YYYY HH24:MI'),
TO_DATE(to_char(ASS_START_TIME,'DD/MM/YYYY ')||EXPECTED_ARRIVAL_TIME,'DD/MM/YYYY HH24:MI'),
FROM_ADDRESS,TO_ADDRESS,
start_gps, finished_gps
from ASSIGNING_WORK_TB w WHERE
trunc(w.ass_start_time) = i.ASS_START_TIME
and SER in (
 select x from
 (
 select regexp_substr(SER_IN,'[^,]+', 2, level) x from dual
connect by regexp_substr(SER_IN, '[^,]+', 2, level) is not null
));

  END LOOP;

         MSG_OUT := 1;
  EXCEPTION
    WHEN OTHERS THEN
      MSG_OUT := 'HR_ATTENDANCE_PKG' || 'ASSIGNING_WORK_TB_UPDATE_REQ ' ||   SQLERRM;
  END ASSIGNING_WORK_TB_UPDATE_REQ;

----------------------------------------------------------------------

PROCEDURE ASSIGNING_WORK_TB_DELETE (
SER_IN  IN ASSIGNING_WORK_TB.SER%TYPE ,
MSG_OUT OUT VARCHAR2) AS
BEGIN
 DELETE  FROM  ASSIGNING_WORK_TB
 WHERE  SER = SER_IN  ;
  MSG_OUT:=  SQL%ROWCOUNT;
EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'ASSIGNING_WORK_TB_DELETE '|| SQLERRM;
END ASSIGNING_WORK_TB_DELETE ;

---------------------------------------------------------------------------

PROCEDURE ASSIGNING_WORK_TB_GET (
SER_IN  IN ASSIGNING_WORK_TB.SER%TYPE ,
 REF_CUR_OUT OUT SYS_REFCURSOR,MSG_OUT OUT VARCHAR2   ) AS
BEGIN
 OPEN REF_CUR_OUT FOR
SELECT  M.* ,
 TO_CHAR(M.ENTRY_DATE,'HH24:MI DD/MM/YYYY') ENTRY_DATE,
 EMP_PKG.GET_EMP_NAME( M.EMP_NO)  EMP_NO_NAME ,
 TO_CHAR(M.ass_start_time,'HH24:MI') ass_start_time ,
 TO_CHAR(M.ass_end_time,'HH24:MI')  ass_end_time ,
 TO_CHAR(M.ass_start_time,'DD/MM/YYYY') ass_start_date ,
 TO_CHAR(M.ass_end_time,'DD/MM/YYYY')  ass_end_date ,
 SETTING_PKG.CONSTANT_DETAILS_TB_GET_NAME(1 ,M.ADOPT)  ADOPT_NAME ,
 USER_PKG.GET_USER_NAME(M.ENTRY_USER)  ENTRY_USER_NAME ,
 SETTING_PKG.GCC_BRANCHES_TB_GET_NAME (M.BRANCH_ID)  BRANCH_ID_NAME ,
 SETTING_PKG.CONSTANT_DETAILS_TB_GET_NAME(247 , M.EMP_WORK)  EMP_WORK_NAME ,
 SALARY_EMP_PKG.CONSTANTS_SAL_DET_GET_NAME( 14 , EMP_PKG.GET_EMP_JOB_TITLE_NO( M.EMP_NO ) ) EMP_JOB_TITLE_NAME ,
 SALARY_EMP_PKG.CONSTANTS_SAL_DET_GET_NAME( 7  , EMP_PKG.GET_EMP_HEAD_DEPARTMENT_NO( M.EMP_NO ) ) EMP_HEAD_DEPARTMENT_NAME ,
 GET_MANAGER_EMAIL(M.EMP_NO) MANAGER_EMAIL
FROM ASSIGNING_WORK_TB  M
 WHERE M.SER = SER_IN  ;
   MSG_OUT:= 1;
EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'ASSIGNING_WORK_TB_GET '|| SQLERRM;
END ASSIGNING_WORK_TB_GET ;


------------------------------------------------------------------------

PROCEDURE ASSIGNING_WORK_TB_GET_ALL (
REF_CUR_OUT OUT SYS_REFCURSOR,MSG_OUT OUT VARCHAR2   )
AS
BEGIN
 OPEN REF_CUR_OUT FOR
SELECT  M.* ,
 EMP_PKG.GET_EMP_NAME( M.EMP_NO)  EMP_NO_NAME ,
 SETTING_PKG.CONSTANT_DETAILS_TB_GET_NAME(1 ,M.ADOPT)  ADOPT_NAME ,
 USER_PKG.GET_USER_NAME(M.ENTRY_USER)  ENTRY_USER_NAME ,
 SETTING_PKG.GCC_BRANCHES_TB_GET_NAME (M.BRANCH_ID)  BRANCH_ID_NAME
FROM ASSIGNING_WORK_TB  M ;
   MSG_OUT:= 1;
EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'ASSIGNING_WORK_TB_GET_ALL '|| SQLERRM;
END ASSIGNING_WORK_TB_GET_ALL ;

-------------------------------------------------------------

PROCEDURE ASSIGNING_WORK_TB_LIST (INSQL IN VARCHAR2 ,
 OFFSET    NUMBER,ROW    NUMBER ,
  REF_CUR_OUT OUT SYS_REFCURSOR,MSG_OUT OUT VARCHAR2  ) AS
 XSQL VARCHAR2(4000);
BEGIN
XSQL:= 'SELECT * FROM (
SELECT  M.* ,
 TO_CHAR(ENTRY_DATE,''DD/MM/YYYY HH24:MI'') ENTRY_DATE_TIME ,
 EMP_PKG.GET_EMP_NAME( M.EMP_NO)  EMP_NO_NAME ,
 TO_CHAR(M.ASS_START_TIME, ''DD/MM/YYYY'')  ASS_START_DATE ,
 TO_CHAR(M.ASS_START_TIME, ''HH24:MI'') START_TIME ,
 TO_CHAR(M.ASS_END_TIME, ''HH24:MI'') END_TIME ,
 QF_PKG.GET_DAY_NAME_AR(m.ASS_START_TIME) DAY_AR ,
 SETTING_PKG.CONSTANT_DETAILS_TB_GET_NAME(241 ,M.FOOD_NO)  FOOD_NO_NAME ,
 SETTING_PKG.CONSTANT_DETAILS_TB_GET_NAME(222 ,M.ADOPT)  ADOPT_NAME ,
 USER_PKG.GET_USER_NAME(M.ENTRY_USER)  ENTRY_USER_NAME ,
 USER_PKG.GET_USER_NAME(M.ADOPT_USER_20) ADOPT_USER_20_NAME ,
 HR_ATTENDANCE_PKG.GET_EMP_ATTENDANCE_LEAVE(M.ADOPT_USER_20,M.ASS_START_TIME) ADOPT_USER_20_LEAVE_TIME ,
 SETTING_PKG.GCC_BRANCHES_TB_GET_NAME (M.BRANCH_ID)  BRANCH_ID_NAME ,
 SETTING_PKG.CONSTANT_DETAILS_TB_GET_NAME(247 , M.EMP_WORK)  EMP_WORK_NAME ,
ROW_NUMBER() OVER ( ORDER BY  M.SER DESC) RN
FROM ASSIGNING_WORK_TB  M '||INSQL||
' ORDER BY SER DESC )
 WHERE RN BETWEEN '||(OFFSET +1)||' AND '|| ROW ||' ORDER BY RN ';
  OPEN REF_CUR_OUT FOR XSQL;
     MSG_OUT:= 1;
  EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'ASSIGNING_WORK_TB_LIST '|| SQLERRM;
 END  ASSIGNING_WORK_TB_LIST ;

-------------------------------------------------------------

PROCEDURE ASSIGNING_WORK_TB_ADOPT(
SER_IN  IN ASSIGNING_WORK_TB.SER%TYPE ,
ADOPT_IN  IN ASSIGNING_WORK_TB.ADOPT%TYPE ,
MSG_OUT OUT VARCHAR2)  AS
L_permi_type NUMBER;
L_chk NUMBER;
L_DUPLICATE NUMBER;
R_ASSIGNING   ASSIGNING_WORK_TB%ROWTYPE;
BEGIN

select * into R_ASSIGNING
from ASSIGNING_WORK_TB a
where a.ser= SER_IN ;

IF ADOPT_IN =0 OR hr_attendance_pkg.ASSIGNING_WORK_TRANS_CHECK(R_ASSIGNING.branch_id, R_ASSIGNING.ass_start_time)=0 THEN

    CASE ADOPT_IN

     WHEN  0 THEN
     UPDATE ASSIGNING_WORK_TB SET
     ADOPT  = ADOPT_IN ,
     CANCEL_DATE = SYSDATE ,
     CANCEL_USER = USER_PKG.GET_USER_ID
     WHERE SER = SER_IN and adopt=1 and entry_user= USER_PKG.GET_USER_ID ;
     MSG_OUT:=  SQL%ROWCOUNT;

     WHEN  -20 THEN
     UPDATE ASSIGNING_WORK_TB SET
     ADOPT  = 0 ,
     CANCEL_DATE = SYSDATE ,
     CANCEL_USER = USER_PKG.GET_USER_ID
     WHERE SER = SER_IN and adopt=20 ;
     MSG_OUT:=  SQL%ROWCOUNT;

     WHEN  -30 THEN
     UPDATE ASSIGNING_WORK_TB SET
     ADOPT  = 0 ,
     CANCEL_DATE = SYSDATE ,
     CANCEL_USER = USER_PKG.GET_USER_ID
     WHERE SER = SER_IN and adopt in (30,10) ;
     MSG_OUT:=  SQL%ROWCOUNT;

     WHEN  -40 THEN
     UPDATE ASSIGNING_WORK_TB SET
     ADOPT  = 30
     WHERE SER = SER_IN and adopt=40 ;
     MSG_OUT:=  SQL%ROWCOUNT;

     WHEN  10 THEN

    ---- فحص تكرار التكليف قبل اعتماد التكليف -- check duplicate

     select * into R_ASSIGNING
     from ASSIGNING_WORK_TB a
     where a.ser= SER_IN ;

     L_DUPLICATE :=0;

    SELECT COUNT(0) INTO L_chk
    from ASSIGNING_WORK_TB a
    where a.adopt >= 10
    and a.emp_no = R_ASSIGNING.emp_no
    and TRUNC(a.ass_start_time) = TRUNC(R_ASSIGNING.ass_start_time) ;

     IF L_chk = 0 THEN
        L_DUPLICATE := 1;
     END IF;

    ----- check duplicate

     IF L_DUPLICATE = 1 THEN

     UPDATE ASSIGNING_WORK_TB SET
     ADOPT  = ADOPT_IN
     WHERE SER = SER_IN and adopt=1 and entry_user= USER_PKG.GET_USER_ID ;
     MSG_OUT:=  SQL%ROWCOUNT;

     ELSE
        MSG_OUT:= 'DUPLICATE -  التكليف مكرر';
     END IF;

     WHEN  20 THEN
     UPDATE ASSIGNING_WORK_TB SET
     ADOPT  = case WHEN ass_end_time is not null then 30 else 20 end , --- ADOPT_IN  ,
     ADOPT_DATE_20 = SYSDATE  ,
     ADOPT_USER_20 = USER_PKG.GET_USER_ID
     WHERE SER = SER_IN and adopt=10 and emp_no != user_pkg.get_user_emp_no ;
     MSG_OUT:=  SQL%ROWCOUNT;

     WHEN 30 THEN

     -- التأكد ان وقت نهاية العمل بعد وقت بدايته
     select update_time(SYSDATE, 5, '+') - a.ass_start_time into L_chk from ASSIGNING_WORK_TB a where a.ser= SER_IN ;

     UPDATE ASSIGNING_WORK_TB SET
     ADOPT  = ADOPT_IN  ,
     ass_end_time= update_time(SYSDATE, 5, '+') ,
     ASS_DURATION  =  ROUND( (HR_ATTENDANCE_PKG.GET_INTERVAL_MINUTES(ass_start_time , update_time(SYSDATE, 5, '+') ) / 60), 2) ,
     CALC_DURATION =  ROUND( (HR_ATTENDANCE_PKG.GET_INTERVAL_MINUTES(ass_start_time , update_time(SYSDATE, 5, '+') ) / 60), 2) ,
     ADOPT_DATE_30 = SYSDATE  ,
     ADOPT_USER_30 = USER_PKG.GET_USER_ID
     WHERE SER = SER_IN  and adopt=20 and L_chk > 0 ;
     MSG_OUT:=  SQL%ROWCOUNT;

     WHEN  40 THEN
     UPDATE ASSIGNING_WORK_TB SET
     ADOPT  = ADOPT_IN  ,
     ADOPT_DATE_40 = SYSDATE  ,
     ADOPT_USER_40 = USER_PKG.GET_USER_ID
     WHERE SER = SER_IN and adopt=30 and ass_duration >= 0 and calc_duration >= 0 ;
     MSG_OUT:=  SQL%ROWCOUNT;

     ELSE
      MSG_OUT:= 'ERROR';
     END CASE;

ELSE
   MSG_OUT:= 'ASSIGNING_TRANS_CHECK - لا يمكن اتمام العملية بسبب ترحيل تكاليف هذا الشهر';
END IF ;


 EXCEPTION
 WHEN OTHERS THEN
 MSG_OUT :=  'HR_ATTENDANCE_PKG'||'ASSIGNING_WORK_TB_ADOPT '|| SQLERRM;
 END  ASSIGNING_WORK_TB_ADOPT ;

----------------------------------------------------------------------------

PROCEDURE ASSIGNING_WORK_TB_GET_SUM(
EMP_NO_IN IN NUMBER , BRANCH_IN IN NUMBER , DATE_FROM_IN IN DATE, DATE_TO_IN IN DATE ,
REF_CUR_OUT OUT SYS_REFCURSOR, MSG_OUT OUT VARCHAR2 )  AS
BEGIN
 OPEN REF_CUR_OUT FOR

SELECT  emp_pkg.get_emp_branch(a.emp_no) branch_id, emp_pkg.get_emp_branch_name(a.emp_no) branch_name ,
a.emp_no,  emp_pkg.get_emp_name(a.emp_no) emp_no_name , sum( a.calc_duration ) s_calc_duration
from gfc_hr.assigning_work_tb  a
where TRUNC(a.ass_start_time) between DATE_FROM_IN and DATE_TO_IN
and a.adopt = 40
and ( a.emp_no = EMP_NO_IN OR EMP_NO_IN IS NULL )
and ( emp_pkg.get_emp_branch(a.emp_no) = BRANCH_IN OR BRANCH_IN IS NULL )
group by a.emp_no
order by 1 , 3 ;

 MSG_OUT:= 1;

EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'ASSIGNING_WORK_TB_GET_SUM '|| SQLERRM;
END ASSIGNING_WORK_TB_GET_SUM ;

----------------------------------------------------------------------------

PROCEDURE EVA_EMPS_STRUCTURE_CHILD_GET (
EMPLOYEE_NO_IN  IN HR_EMPS_STRUCTURE_TB.EMPLOYEE_NO%TYPE ,
ACTION_IN IN VARCHAR2,
REF_CUR_OUT OUT SYS_REFCURSOR , MSG_OUT OUT VARCHAR2) AS
BEGIN

IF  ACTION_IN = 'hr_admin' THEN

    OPEN REF_CUR_OUT FOR
    SELECT A.EMPLOYEE_NO  EMP_NO , EMP_PKG.GET_EMP_NAME (A.EMPLOYEE_NO ) EMP_NAME
    FROM HR_EMPS_STRUCTURE_TB A
    WHERE A.EMPLOYEE_NO != -1
    order by 1 ;

ELSIF ACTION_IN in ( 'move_admin' , 'hr_branch' ) THEN

    OPEN REF_CUR_OUT FOR
    SELECT A.EMPLOYEE_NO  EMP_NO , EMP_PKG.GET_EMP_NAME (A.EMPLOYEE_NO ) EMP_NAME
    FROM HR_EMPS_STRUCTURE_TB A , USERS_PROG_TB U --- OLD: EMPLOYEES_TB
    WHERE A.EMPLOYEE_NO = U.EMP_NO
    AND   A.EMPLOYEE_NO != -1
    AND   U.BRANCH = USER_PKG.GET_USER_BRANCH_NO
      UNION ALL -- موظفي مشروع الفاقد - النسبة
    SELECT S.NO  EMP_NO , S.NAME  EMP_NAME
    FROM GFC.EMPLOYEES_TB  S
    WHERE S.NO >= 70000
    AND   S.BRANCH = USER_PKG.GET_USER_BRANCH_NO
    ORDER BY 1 ;

ELSE

    OPEN REF_CUR_OUT FOR
    SELECT A.EMPLOYEE_NO  EMP_NO , EMP_PKG.GET_EMP_NAME (A.EMPLOYEE_NO ) EMP_NAME
    FROM HR_EMPS_STRUCTURE_TB A
    START WITH A.EMPLOYEE_NO = EMPLOYEE_NO_IN
    CONNECT BY PRIOR  A.EMPLOYEE_NO = A.MANAGER_NO
       UNION
    SELECT A.EMPLOYEE_NO  EMP_NO , EMP_PKG.GET_EMP_NAME (A.EMPLOYEE_NO ) EMP_NAME
    FROM HR_EMPS_STRUCTURE_TB A
    WHERE A.MANAGER_NO = HR_ATTENDANCE_PKG.GET_MANAGER_NO_BY_ALTERNATIVE(EMPLOYEE_NO_IN);

END IF;

 MSG_OUT:= 1;

EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'EVA_EMPS_STRUCTURE_CHILD_GET '|| SQLERRM;
END EVA_EMPS_STRUCTURE_CHILD_GET ;

----------------------------------------------------------------------------------

FUNCTION  GET_MANAGER_EMAIL( EMP_NO_IN   NUMBER   ) RETURN VARCHAR2 IS
RES VARCHAR2(80);
BEGIN

    select a.email INTO RES
    from gfc.users_prog_tb a
    where a.emp_no=
    (
        SELECT a.manager_no
        from gfc_hr.HR_EMPS_STRUCTURE_TB  a
        where a.employee_no= EMP_NO_IN
    )
    and a.email is not null
    and a.email not like 'E_%' ;

    RETURN RES;

EXCEPTION
    WHEN  NO_DATA_FOUND  THEN
        RETURN null;
    WHEN OTHERS  THEN
        RETURN  null;
END GET_MANAGER_EMAIL ;

-------------------------------------------------------------------------------

FUNCTION  GET_MANAGER_NO_BY_ALTERNATIVE( EMP_NO_IN   NUMBER   ) RETURN NUMBER IS
RES NUMBER(10);
BEGIN

 select a.employee_no INTO RES
 from gfc_hr.HR_EMPS_STRUCTURE_TB a
 where A.alternative_manager_no = EMP_NO_IN ;

 RETURN  nvl(RES, -10 ) ;

EXCEPTION
    WHEN  NO_DATA_FOUND  THEN
        RETURN -10;
    WHEN OTHERS  THEN
        RETURN -10;
END GET_MANAGER_NO_BY_ALTERNATIVE ;

--------------------------------------------------------------------------------

FUNCTION UPDATE_TIME
( DATE_TIME IN DATE,  NUM IN NUMBER, ACTION IN VARCHAR2 ) RETURN DATE IS
RES DATE;
V_HOUR NUMBER;
V_MINT NUMBER;
V_DIFF NUMBER;
BEGIN

V_HOUR:= TO_CHAR(DATE_TIME,'HH24') ;
V_MINT:= TO_CHAR(DATE_TIME,'MI') ; -- MIN 42
V_DIFF:= MOD( V_MINT , NUM); -- IN 42 OUT 2

IF ACTION = '+' THEN
    IF V_DIFF > 0 THEN
        V_DIFF:= NUM - V_DIFF; -- 5-2 = 3
        V_MINT:= V_MINT + V_DIFF; -- 42+3= 45
    END IF;

    IF V_MINT = 60 THEN
        RES:= TO_DATE(  TO_CHAR(DATE_TIME,'DD/MM/YYYY ')||(V_HOUR+1)||':00'  ,  'DD/MM/YYYY HH24:MI' ) ;
    ELSE
        RES:= TO_DATE(  TO_CHAR(DATE_TIME,'DD/MM/YYYY HH24:')||V_MINT  ,  'DD/MM/YYYY HH24:MI' ) ;
    END IF;

ELSIF ACTION = '-' THEN
    V_MINT:= V_MINT - V_DIFF;  -- 42-2= 40
    RES:= TO_DATE(  TO_CHAR(DATE_TIME,'DD/MM/YYYY HH24:')||V_MINT  ,  'DD/MM/YYYY HH24:MI' ) ;
ELSE
    RES:= DATE_TIME;
END IF;

RETURN NVL(RES, DATE_TIME);

EXCEPTION
    WHEN  NO_DATA_FOUND  THEN
    RETURN DATE_TIME;
    WHEN OTHERS  THEN
     RETURN  DATE_TIME;
END UPDATE_TIME ;

--------------------------------------------------------------------------------

FUNCTION  GET_INTERVAL_MINUTES
( START_DATE IN DATE,  END_DATE IN DATE  ) RETURN NUMBER IS
RES NUMBER;
BEGIN

RES:= TRUNC( ((END_DATE - START_DATE)*24*60 + 0.01 ) , 1 ) ;

RETURN NVL(RES, 0);

EXCEPTION
    WHEN  NO_DATA_FOUND  THEN
    RETURN 0;
    WHEN OTHERS  THEN
     RETURN  0;
END GET_INTERVAL_MINUTES ;

--------------------------------------------------------------------------------

FUNCTION GET_VACATION_TYPE_CONSTANT
( VAC_TYPE IN NUMBER )  RETURN NUMBER IS
RES NUMBER;
BEGIN

select a.account_id into RES
from gfc.constant_details_tb a
where a.tb_no= 214  and a.con_no = VAC_TYPE ;

 RETURN NVL(RES, 1);

EXCEPTION
    WHEN  NO_DATA_FOUND  THEN
    RETURN 1;
    WHEN OTHERS  THEN
     RETURN  1;
END GET_VACATION_TYPE_CONSTANT ;

--------------------------------------------------------------------------------

PROCEDURE CLOCK_DATA_VW_LIST (INSQL IN VARCHAR2 , INSQL2 IN VARCHAR2 ,
 OFFSET    NUMBER,ROW    NUMBER ,
  REF_CUR_OUT OUT SYS_REFCURSOR,MSG_OUT OUT VARCHAR2  ) AS
 XSQL VARCHAR2(4000);
BEGIN

XSQL:= ' SELECT * FROM (
SELECT  m.ser, m.emp_no, M.FUNCTION_KEY, m.branch_clock ,
 EMP_PKG.GET_EMP_NAME( M.EMP_NO)  EMP_NO_NAME ,
 TO_CHAR(M.entry_date, ''DD/MM/YYYY'')  ENTRY_DATE ,
 TO_CHAR(M.entry_date, ''HH24:MI'')  ENTRY_TIME ,
 QF_PKG.GET_DAY_NAME_AR(m.entry_date) DAY_AR ,
 QF_PKG.GET_DAY_NAME_EN(m.entry_date) DAY_EN ,
 SETTING_PKG.CONSTANT_DETAILS_TB_GET_NAME(225 ,M.FUNCTION_KEY)  FUNCTION_KEY_NAME ,
 SETTING_PKG.GCC_BRANCHES_TB_GET_NAME (M.BRANCH_ID)  BRANCH_ID_NAME ,
 transaction_pkg.ATTENDACE_NO_ENTRY_LEAVE_CHECK(m.ser , M.EMP_NO, M.FUNCTION_KEY ) ATTENDACE_NO_ENTRY_LEAVE_CHECK ,
 case when m.function_key=1 then   hr_attendance_pkg.OFF_WORK_HOURS_DELAY_START( hr_attendance_pkg.OFF_WORK_HOURS_DETECT_ROW(1, m.entry_date) , m.entry_date )    else -10 end  DELAY_START ,
 case when m.function_key=4 then   hr_attendance_pkg.OFF_WORK_HOURS_EARLY_END  ( hr_attendance_pkg.OFF_WORK_HOURS_DETECT_ROW(1, m.entry_date) , m.entry_date )    else -10 end  EARLY_END ,
 case when m.function_key=4 then   hr_attendance_pkg.OFF_WORK_HOURS_OVER_TIME  ( hr_attendance_pkg.OFF_WORK_HOURS_DETECT_ROW(1, m.entry_date) , m.entry_date )    else -10 end  OVER_TIME ,
 ROW_NUMBER() OVER (PARTITION BY  TRUNC(m.entry_date), m.emp_no ORDER BY m.entry_date ) CNT_DUPLICATE ,
 ROW_NUMBER() OVER ( ORDER BY  M.SER DESC) RN
FROM CLOCK_DATA_VW  M '||INSQL||
' ORDER BY SER DESC )
 WHERE 1=1 '||INSQL2||' and RN BETWEEN '||(OFFSET +1)||' AND '|| ROW ||' ORDER BY RN ';

 OPEN REF_CUR_OUT FOR XSQL;

     MSG_OUT:= 1 ;
  EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'CLOCK_DATA_VW_LIST '|| SQLERRM;
 END  CLOCK_DATA_VW_LIST ;

--------------------------------------------------------------------------------

PROCEDURE DATA_ATTENDANCE_UPDATE (
SER_IN  IN NUMBER ,
EMP_NO_IN  IN NUMBER ,
STATUS_IN  IN NUMBER ,
MSG_OUT OUT VARCHAR2) AS
BEGIN

    UPDATE DATA.ATTENDANCE A SET
    A.STATUS = STATUS_IN
    WHERE A.NO = SER_IN
    AND A.EMPLOYEENO = EMP_NO_IN
    AND A.STATUS != STATUS_IN ;

  MSG_OUT:=  SQL%ROWCOUNT;
EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'DATA_ATTENDANCE_UPDATE '|| SQLERRM;
END DATA_ATTENDANCE_UPDATE ;

--------------------------------------------------------------------------------

PROCEDURE EMPS_ABSENCE_LIST ( INSQL IN VARCHAR2, OFFSET  NUMBER, ROW NUMBER , DT1 DATE, DT2 DATE, QR_TYPE VARCHAR2, IS_NOTE NUMBER,
REF_CUR_OUT OUT SYS_REFCURSOR, MSG_OUT OUT VARCHAR2 ) AS
XSQL VARCHAR2(6000);
BEGIN

IF QR_TYPE = 'DATA' THEN

XSQL:= ' SELECT * FROM (

SELECT aa.* , ROW_NUMBER() OVER ( ORDER BY aa.DT DESC , aa.EMP_NO ) RN
FROM (
SELECT m.DT , QF_PKG.GET_DAY_NAME_AR(m.dt) DAY_AR ,
e.no EMP_NO , EMP_PKG.GET_EMP_NAME(e.no)  EMP_NO_NAME ,
EMP_PKG.GET_EMP_BRANCH(e.no) BRANCH_ID , EMP_PKG.GET_EMP_BRANCH_NAME(e.no) BRANCH_ID_NAME ,
HR_ATTENDANCE_PKG.EMPS_ABSENCE_REASON_GET_SER(e.no ,m.DT) REASON_SER , HR_ATTENDANCE_PKG.EMPS_ABSENCE_REASON_GET_REASON(e.no ,m.DT) REASON_NO ,
    (
        select count(0) cnt
        from gfc_hr.vacation_request_tb v
        where v.emp_no= e.no
        and v.adopt >= 10
        and m.dt BETWEEN v.vac_date and v.vac_end_date
    ) IS_VACATION ,

    (
        select SETTING_PKG.CONSTANT_DETAILS_TB_GET_NAME(214 , max(V.VAC_TYPE) )  VAC_TYPE_NAME
        from gfc_hr.vacation_request_tb v
        where v.emp_no= e.no
        and v.adopt >= 10
        and m.dt BETWEEN v.vac_date and v.vac_end_date
    ) VAC_TYPE_NAME ,

    (
        select count(0) cnt
        from gfc_hr.exit_permission_tb x
        where x.emp_no= e.no
        and x.p_date= m.dt
        and TO_CHAR(x.p_exit_time,''HH24MI'') = ''0800''
        and x.adopt >= 10
    ) IS_EXIT ,

    (
        SELECT count(0) cnt
        from gfc_hr.official_vacations_tb  a
        where a.v_date= m.dt
        and a.status= 1
    ) IS_OFFICIAL_VACATION ,

    (
        select count(0) cnt
        FROM data.attendance a
        WHERE a.employeeno= e.no and a.tdate = m.dt
    ) HAVE_FINGERPRINT

from
(
    SELECT ( TO_DATE('''||DT1||''') + level-1 ) dt
    FROM DUAL d
    CONNECT BY LEVEL <= ( TO_DATE('''||DT2||''') - TO_DATE('''||DT1||''') + 1 )
    order by dt desc
) M , data.EMPLOYEES E
WHERE e.is_active > 0
AND HR_ATTENDANCE_PKG.OFF_WORK_HOURS_DETECT_ROW(1,m.dt) > 0
 '||INSQL||'
and NOT EXISTS
(
    select 1
    FROM data.attendance a
    WHERE a.status=1 AND a.employeeno= e.no and a.tdate = m.dt
)
ORDER BY M.DT DESC , E.NO

) aa
 WHERE ( ( '||IS_NOTE||'=1  and ( aa.IS_VACATION=1 or  aa.IS_EXIT=1 or  aa.HAVE_FINGERPRINT>=1 or  aa.IS_OFFICIAL_VACATION=1 )  )
 OR      ( '||IS_NOTE||'=2  and ( aa.IS_VACATION=0 and aa.IS_EXIT=0 and aa.HAVE_FINGERPRINT=0 and aa.IS_OFFICIAL_VACATION=0 )  )
 OR       '||IS_NOTE||'=0  )
 ) bb

 where bb.RN BETWEEN '||(OFFSET +1)||' AND '|| ROW ||' ORDER BY RN ';


ELSIF QR_TYPE = 'COUNT' THEN

XSQL:= ' SELECT count(0) NUM_ROWS FROM (
SELECT
    (
        select count(0) cnt
        from gfc_hr.vacation_request_tb v
        where v.emp_no= e.no
        and v.adopt >= 10
        and m.dt BETWEEN v.vac_date and v.vac_end_date
    ) IS_VACATION ,
    (
        select count(0) cnt
        from gfc_hr.exit_permission_tb x
        where x.emp_no= e.no
        and x.p_date= m.dt
        and TO_CHAR(x.p_exit_time,''HH24MI'') = ''0800''
        and x.adopt >= 10
    ) IS_EXIT ,
    (
        SELECT count(0) cnt
        from gfc_hr.official_vacations_tb  a
        where a.v_date= m.dt
        and a.status= 1
    ) IS_OFFICIAL_VACATION ,
    (
        select count(0) cnt
        FROM data.attendance a
        WHERE a.employeeno= e.no and a.tdate = m.dt
    ) HAVE_FINGERPRINT
from
(
    SELECT ( TO_DATE('''||DT1||''') + level-1 ) dt
    FROM DUAL d
    CONNECT BY LEVEL <= ( TO_DATE('''||DT2||''') - TO_DATE('''||DT1||''') + 1 )
    order by dt desc
) M , data.EMPLOYEES E
WHERE e.is_active > 0
AND HR_ATTENDANCE_PKG.OFF_WORK_HOURS_DETECT_ROW(1,m.dt) > 0
 '||INSQL||'
and NOT EXISTS
(
    select 1
    FROM data.attendance a
    WHERE a.status=1 AND a.employeeno= e.no and a.tdate = m.dt
)

) aa
 WHERE ( ( '||IS_NOTE||'=1  and ( aa.IS_VACATION=1 or  aa.IS_EXIT=1 or  aa.HAVE_FINGERPRINT>=1 or  aa.IS_OFFICIAL_VACATION=1 )  )
 OR      ( '||IS_NOTE||'=2  and ( aa.IS_VACATION=0 and aa.IS_EXIT=0 and aa.HAVE_FINGERPRINT=0 and aa.IS_OFFICIAL_VACATION=0 )  )
 OR        '||IS_NOTE||'=0  )  ';

/*
OLD Code
XSQL:= ' SELECT count(0) NUM_ROWS
from
(
    SELECT ( TO_DATE('''||DT1||''') + level-1 ) dt
    FROM DUAL d
    CONNECT BY LEVEL <= ( TO_DATE('''||DT2||''') - TO_DATE('''||DT1||''') + 1 )
    order by dt desc
) M , data.EMPLOYEES E
WHERE e.is_active > 0
AND qf_pkg.get_day_name_en(m.dt) != ''FRIDAY''  '||INSQL||'
and NOT EXISTS
(
    select 1
    FROM data.attendance a
    WHERE a.status=1 AND a.employeeno= e.no and a.tdate = m.dt
) ';
*/

END IF;

OPEN REF_CUR_OUT FOR XSQL;

     MSG_OUT:= 1 ;
 EXCEPTION
 WHEN OTHERS THEN
 MSG_OUT :=  'HR_ATTENDANCE_PKG'||'EMPS_ABSENCE_LIST '|| SQLERRM;
 END  EMPS_ABSENCE_LIST ;

-------------------------------------------------------------------------------------------------

PROCEDURE EMPS_ABSENCE_REASON_INSERT (
EMP_NO_IN IN EMPS_ABSENCE_REASON_TB.EMP_NO%TYPE,
ABSENCE_DATE_IN IN EMPS_ABSENCE_REASON_TB.ABSENCE_DATE%TYPE,
REASON_NO_IN IN EMPS_ABSENCE_REASON_TB.REASON_NO%TYPE,
MSG_OUT OUT VARCHAR2 ) AS
SEQ_VAL NUMBER ;
BEGIN
    SEQ_VAL := EMPS_ABSENCE_REASON_SEQ.NEXTVAL;
    INSERT INTO EMPS_ABSENCE_REASON_TB
    ( SER, EMP_NO, ABSENCE_DATE, REASON_NO, ENTRY_USER, ENTRY_DATE )
    VALUES
    ( SEQ_VAL, EMP_NO_IN, ABSENCE_DATE_IN, REASON_NO_IN, USER_PKG.GET_USER_ID, SYSDATE ) ;
    MSG_OUT:= SEQ_VAL ;
EXCEPTION
WHEN OTHERS THEN
MSG_OUT := 'HR_ATTENDANCE_PKG'||'EMPS_ABSENCE_REASON_INSERT '|| SQLERRM;
END EMPS_ABSENCE_REASON_INSERT;

-------------------------------------------------------------------------------------------------

PROCEDURE EMPS_ABSENCE_REASON_UPDATE (
SER_IN IN EMPS_ABSENCE_REASON_TB.SER%TYPE,
EMP_NO_IN IN EMPS_ABSENCE_REASON_TB.EMP_NO%TYPE,
REASON_NO_IN IN EMPS_ABSENCE_REASON_TB.REASON_NO%TYPE,
MSG_OUT OUT VARCHAR2 ) AS
BEGIN

    UPDATE EMPS_ABSENCE_REASON_TB SET
    REASON_NO = REASON_NO_IN ,
    UPDATE_USER = USER_PKG.GET_USER_ID ,
    UPDATE_DATE = SYSDATE
    WHERE SER = SER_IN AND EMP_NO = EMP_NO_IN ;

    MSG_OUT:= SQL%ROWCOUNT ;

EXCEPTION
WHEN OTHERS THEN
MSG_OUT := 'HR_ATTENDANCE_PKG'||'EMPS_ABSENCE_REASON_UPDATE '|| SQLERRM;
END EMPS_ABSENCE_REASON_UPDATE;

----------------------------------------------------------------------

FUNCTION EMPS_ABSENCE_REASON_GET_SER (
EMP_NO_IN IN EMPS_ABSENCE_REASON_TB.EMP_NO%TYPE,
ABSENCE_DATE_IN IN EMPS_ABSENCE_REASON_TB.ABSENCE_DATE%TYPE ) RETURN  NUMBER IS
RES  NUMBER;
BEGIN

    SELECT A.SER INTO RES
    FROM EMPS_ABSENCE_REASON_TB  A
    WHERE A.EMP_NO = EMP_NO_IN
    AND A.ABSENCE_DATE = ABSENCE_DATE_IN ;

RETURN RES ;

EXCEPTION
WHEN NO_DATA_FOUND  THEN
             RETURN NULL;
WHEN OTHERS  THEN
             RETURN NULL;
END  EMPS_ABSENCE_REASON_GET_SER ;

----------------------------------------------------------------------

FUNCTION EMPS_ABSENCE_REASON_GET_REASON (
EMP_NO_IN IN EMPS_ABSENCE_REASON_TB.EMP_NO%TYPE,
ABSENCE_DATE_IN IN EMPS_ABSENCE_REASON_TB.ABSENCE_DATE%TYPE ) RETURN  NUMBER IS
RES  NUMBER;
BEGIN

    SELECT A.REASON_NO INTO RES
    FROM EMPS_ABSENCE_REASON_TB  A
    WHERE A.EMP_NO = EMP_NO_IN
    AND A.ABSENCE_DATE = ABSENCE_DATE_IN ;

RETURN RES ;

EXCEPTION
WHEN NO_DATA_FOUND  THEN
             RETURN NULL;
WHEN OTHERS  THEN
             RETURN NULL;
END  EMPS_ABSENCE_REASON_GET_REASON ;

------------------------------------------------------------------------------

/*
FUNCTION EVA_EMPS_STRUCTURE_CHILD (
EMPLOYEE_NO_IN  IN EVALUATIONS_EMPS_STRUCTURE_TB.EMPLOYEE_NO%TYPE ) RETURN VARCHAR2  IS
RES VARCHAR2(500) ;
BEGIN

SELECT
 LISTAGG(EMPLOYEE_NO, ',')
          WITHIN GROUP
           (ORDER BY EMPLOYEE_NO)  INTO RES
FROM
(SELECT A.EMPLOYEE_NO
FROM EVALUATIONS_EMPS_STRUCTURE_TB A
WHERE A.EMPLOYEE_NO     != EMPLOYEE_NO_IN
START WITH A.EMPLOYEE_NO = EMPLOYEE_NO_IN
CONNECT BY PRIOR  A.EMPLOYEE_NO =A.MANAGER_NO ) ;


RETURN NVL(RES,-1000);
EXCEPTION
    WHEN  NO_DATA_FOUND  THEN
    RETURN '0';
    WHEN OTHERS  THEN
     RETURN  '0';
END EVA_EMPS_STRUCTURE_CHILD ;
*/

---------------------------------------------------------------------------------------------

PROCEDURE OFFICIAL_VACATIONS_TB_INSERT (
V_DATE_IN  IN OFFICIAL_VACATIONS_TB.V_DATE%TYPE ,
V_NOTE_IN  IN OFFICIAL_VACATIONS_TB.V_NOTE%TYPE ,
MSG_OUT OUT VARCHAR2) AS
SEQ_VAL NUMBER ;
RES NUMBER(2);
BEGIN

SELECT COUNT(0) INTO RES
FROM OFFICIAL_VACATIONS_TB M
WHERE M.V_DATE = V_DATE_IN AND M.STATUS = 1 ;

IF RES = 0 THEN

SEQ_VAL  := OFFICIAL_VACATIONS_TB_SEQ.NEXTVAL;
INSERT INTO  OFFICIAL_VACATIONS_TB(
SER ,V_DATE ,V_NOTE ,ENTRY_USER ,ENTRY_DATE ,STATUS ) VALUES
(SEQ_VAL   ,V_DATE_IN ,V_NOTE_IN ,USER_PKG.GET_USER_ID  , SYSDATE  ,1 ) ;

END IF;

MSG_OUT:= NVL(SEQ_VAL,0) ;

EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'OFFICIAL_VACATIONS_TB_INSERT '|| SQLERRM;
END OFFICIAL_VACATIONS_TB_INSERT ;

---------------------------------------------------------------------------

PROCEDURE OFFICIAL_VACATIONS_TB_GET (
SER_IN  IN OFFICIAL_VACATIONS_TB.SER%TYPE ,
 REF_CUR_OUT OUT SYS_REFCURSOR,MSG_OUT OUT VARCHAR2   ) AS
BEGIN
 OPEN REF_CUR_OUT FOR
SELECT  M.*
FROM OFFICIAL_VACATIONS_TB  M
 WHERE M.SER = SER_IN  ;
   MSG_OUT:= 1;
EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'OFFICIAL_VACATIONS_TB_GET '|| SQLERRM;
END OFFICIAL_VACATIONS_TB_GET ;

-------------------------------------------------------------

PROCEDURE OFFICIAL_VACATIONS_TB_LIST (INSQL IN VARCHAR2 ,
 OFFSET    NUMBER,ROW    NUMBER ,
  REF_CUR_OUT OUT SYS_REFCURSOR,MSG_OUT OUT VARCHAR2  ) AS
 XSQL VARCHAR2(4000);
BEGIN
XSQL:= 'SELECT * FROM (
SELECT  M.* ,
QF_PKG.GET_DAY_NAME_AR(m.v_date) DAY_AR ,
USER_PKG.GET_USER_NAME(M.ENTRY_USER)  ENTRY_USER_NAME ,
ROW_NUMBER() OVER ( ORDER BY  M.SER DESC) RN
FROM OFFICIAL_VACATIONS_TB  M '||INSQL||
'ORDER BY SER DESC )
 WHERE RN BETWEEN '||(OFFSET +1)||' AND '|| ROW ||' ORDER BY RN ';
  OPEN REF_CUR_OUT FOR XSQL;
     MSG_OUT:= 1;
  EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'OFFICIAL_VACATIONS_TB_LIST '|| SQLERRM;
 END  OFFICIAL_VACATIONS_TB_LIST ;

-------------------------------------------------------------

PROCEDURE OFFICIAL_VACATIONS_TB_STATUS(
SER_IN  IN OFFICIAL_VACATIONS_TB.SER%TYPE ,
STATUS_IN  NUMBER  , MSG_OUT OUT VARCHAR2)  AS
BEGIN

      UPDATE  OFFICIAL_VACATIONS_TB  SET
      STATUS = STATUS_IN
      WHERE  SER = SER_IN AND STATUS  <> STATUS_IN   ;

  MSG_OUT:=  SQL%ROWCOUNT;
  EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  ' HR_ATTENDANCE_PKG '||' OFFICIAL_VACATIONS_TB_STATUS '|| SQLERRM;
 END  OFFICIAL_VACATIONS_TB_STATUS ;

 ---------------------------------------------------------------------------------------------

PROCEDURE ASSIGNING_WORK_TRANS_TB_INSERT (
BRANCH_ID_IN  IN ASSIGNING_WORK_TRANS_TB.BRANCH_ID%TYPE ,
MONTH_IN  IN ASSIGNING_WORK_TRANS_TB.MONTH%TYPE ,
MSG_OUT OUT VARCHAR2) AS
SEQ_VAL NUMBER ;
BEGIN
SEQ_VAL  := ASSIGNING_WORK_TRANS_TB_SEQ.NEXTVAL;
INSERT INTO  ASSIGNING_WORK_TRANS_TB(
SER ,BRANCH_ID ,MONTH ,ADOPT ,ENTRY_USER ,ENTRY_DATE   ) VALUES
(SEQ_VAL  ,BRANCH_ID_IN , TRUNC(MONTH_IN,'MM') ,1  , USER_PKG.GET_USER_ID  , SYSDATE   ) ;
MSG_OUT:= SEQ_VAL ;
EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'ASSIGNING_WORK_TRANS_TB_INSERT '|| SQLERRM;
END ASSIGNING_WORK_TRANS_TB_INSERT ;

-------------------------------------------------------------------------------------------------

PROCEDURE ASSIGNING_WORK_TRANS_TB_UPDATE (
SER_IN  IN ASSIGNING_WORK_TRANS_TB.SER%TYPE ,
BRANCH_ID_IN  IN ASSIGNING_WORK_TRANS_TB.BRANCH_ID%TYPE ,
MONTH_IN  IN ASSIGNING_WORK_TRANS_TB.MONTH%TYPE ,
MSG_OUT OUT VARCHAR2) AS
BEGIN

UPDATE ASSIGNING_WORK_TRANS_TB SET
    BRANCH_ID = BRANCH_ID_IN   ,
    MONTH = TRUNC(MONTH_IN,'MM')
    WHERE SER = SER_IN  AND ADOPT = 1;
  MSG_OUT:=  SQL%ROWCOUNT;
EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'ASSIGNING_WORK_TRANS_TB_UPDATE '|| SQLERRM;
END ASSIGNING_WORK_TRANS_TB_UPDATE ;

----------------------------------------------------------------------

PROCEDURE ASSIGNING_WORK_TRANS_TB_DELETE (
SER_IN  IN ASSIGNING_WORK_TRANS_TB.SER%TYPE ,
MSG_OUT OUT VARCHAR2) AS
BEGIN
 DELETE  FROM  ASSIGNING_WORK_TRANS_TB
 WHERE  SER = SER_IN AND ADOPT = 1  ;
  MSG_OUT:=  SQL%ROWCOUNT;
EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'ASSIGNING_WORK_TRANS_TB_DELETE '|| SQLERRM;
END ASSIGNING_WORK_TRANS_TB_DELETE ;

---------------------------------------------------------------------------

PROCEDURE ASSIGNING_WORK_TRANS_TB_GET (
SER_IN  IN ASSIGNING_WORK_TRANS_TB.SER%TYPE ,
 REF_CUR_OUT OUT SYS_REFCURSOR,MSG_OUT OUT VARCHAR2   ) AS
BEGIN
 OPEN REF_CUR_OUT FOR
SELECT  M.*
FROM ASSIGNING_WORK_TRANS_TB  M
 WHERE M.SER = SER_IN  ;
   MSG_OUT:= 1;
EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'ASSIGNING_WORK_TRANS_TB_GET '|| SQLERRM;
END ASSIGNING_WORK_TRANS_TB_GET ;

-------------------------------------------------------------

PROCEDURE ASSIGNING_WORK_TRANS_TB_LIST (INSQL IN VARCHAR2 ,
 OFFSET    NUMBER,ROW    NUMBER ,
  REF_CUR_OUT OUT SYS_REFCURSOR,MSG_OUT OUT VARCHAR2  ) AS
 XSQL VARCHAR2(4000);
BEGIN

XSQL:= 'SELECT * FROM (
SELECT  M.* ,
TO_CHAR(m.MONTH,''MM/YYYY'') MONTH_ ,
TO_CHAR(m.ENTRY_DATE,''DD/MM/YYYY HH24:MI'') ENTRY_DATE_TIME ,
 SETTING_PKG.GCC_BRANCHES_TB_GET_NAME (M.BRANCH_ID)  BRANCH_ID_NAME ,
 SETTING_PKG.CONSTANT_DETAILS_TB_GET_NAME(266 ,M.ADOPT)  ADOPT_NAME ,
 USER_PKG.GET_USER_NAME(M.ENTRY_USER)  ENTRY_USER_NAME ,
 USER_PKG.GET_USER_NAME(M.ADOPT_USER_10)  ADOPT_USER_10_NAME ,
ROW_NUMBER() OVER ( ORDER BY  M.SER DESC) RN
FROM ASSIGNING_WORK_TRANS_TB  M '||INSQL||
' ORDER BY SER DESC )
 WHERE RN BETWEEN '||(OFFSET +1)||' AND '|| ROW ||' ORDER BY RN ';
  OPEN REF_CUR_OUT FOR XSQL;
     MSG_OUT:= 1;
  EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'ASSIGNING_WORK_TRANS_TB_LIST '|| SQLERRM;
 END  ASSIGNING_WORK_TRANS_TB_LIST ;

-------------------------------------------------------------

PROCEDURE ASSIGNING_WORK_TRANS_TB_ADOPT(
SER_IN  IN ASSIGNING_WORK_TRANS_TB.SER%TYPE ,
ADOPT_IN  NUMBER  , MSG_OUT OUT VARCHAR2)  AS
v_branch_id NUMBER(2);
v_month date ;
v_sal_month date ;
v_sal_month_n number ;
v_cnt number;
BEGIN

SELECT a.branch_id, a.month into v_branch_id, v_month
FROM ASSIGNING_WORK_TRANS_TB A  WHERE A.ser= SER_IN;

--OLD 202009 = select TO_DATE((max(month)),'YYYYMM') into v_sal_month from data.admin ;

select max(month) into v_sal_month_n  from data.admin ;
select count(0) into  v_cnt   from data.admin a   where a.month = v_sal_month_n ;

IF v_cnt > 100 THEN
    v_sal_month := TO_DATE(v_sal_month_n,'YYYYMM');
ELSE
    v_sal_month := ADD_MONTHS(TO_DATE(v_sal_month_n,'YYYYMM'), -1) ;
END IF;


IF v_month >= v_sal_month THEN

CASE  ADOPT_IN

WHEN 10 THEN

      UPDATE  ASSIGNING_WORK_TRANS_TB  SET
      ADOPT = 10 ,
      ADOPT_USER_10 = USER_PKG.GET_USER_ID  ,
      ADOPT_DATE_10 = SYSDATE
      WHERE  SER = SER_IN  AND ADOPT = 1 ;

      -------------------------------------------------

    IF  SQL%ROWCOUNT = 1 THEN

        insert into  data.overtime
        (emp_no, serial,
        month, date_r, calculated_hours, day, is_taxed, actual_hours, is_active, agree_ma,
        emp_branch, basic_sal, basic_sal_q, source)

        select a.emp_no, (select NVL(MAX(SERIAL),0)+1  FROM data.OVERTIME WHERE EMP_NO = a.emp_NO ) ss ,
        TO_CHAR(ADD_MONTHS(v_month,1), 'YYYYMM') ym, sysdate, a.sum_calc_duration, 0,1, a.sum_calc_duration, 0, 0,
        e.bran, data.CAL_BASIC_emp(a.emp_no) ce , data.CAL_BASIC_Q(a.emp_no) cq , 2 s
        from
        (
            SELECT  a.emp_no,  sum( a.calc_duration ) sum_calc_duration
            from gfc_hr.assigning_work_tb  a
            where TRUNC(a.ass_start_time,'mm') = TRUNC(v_month,'mm')
            and a.adopt = 40
            and  emp_pkg.get_emp_branch(a.emp_no) = v_branch_id
            group by a.emp_no
        ) a , data.employees e
        where a.emp_no=e.no
        order by a.emp_no ;

        MSG_OUT:=  SQL%ROWCOUNT;

    ELSE
        MSG_OUT:= 0;
    END IF;


/**********************************************************************/

WHEN -10 THEN

      UPDATE  ASSIGNING_WORK_TRANS_TB  SET
      ADOPT = 1
      WHERE  SER = SER_IN  AND ADOPT = 10 AND ADOPT_USER_10 = USER_PKG.GET_USER_ID ;

      -------------------------------------------------

    IF  SQL%ROWCOUNT = 1 THEN

        DELETE data.overtime
        where  month= TO_CHAR(ADD_MONTHS(v_month,1), 'YYYYMM')
        and emp_branch in ( select b.branch_no from data.branch  b where b.gcc_bran = v_branch_id  )
        and source= 2 ;

        MSG_OUT:=  SQL%ROWCOUNT;

    ELSE
        MSG_OUT:= 0;
    END IF;


END CASE ;

ELSE
    MSG_OUT:= 'لا يمكن تنفيذ العملية بسبب اعتماد الرواتب';
END IF;

  --MSG_OUT:=  SQL%ROWCOUNT;
  EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'ASSIGNING_WORK_TRANS_TB_ADOPT '|| SQLERRM;
 END  ASSIGNING_WORK_TRANS_TB_ADOPT ;

----------------------------------------------------------------------

FUNCTION ASSIGNING_WORK_TRANS_CHECK(
BRANCH_ID_IN  IN NUMBER ,
DATE_IN  IN DATE ) RETURN  NUMBER IS
RES  NUMBER;
BEGIN

SELECT COUNT(0) INTO RES
FROM ASSIGNING_WORK_TRANS_TB T
WHERE T.BRANCH_ID = BRANCH_ID_IN
AND  TRUNC(T.MONTH,'MM') = TRUNC(DATE_IN,'MM')
AND T.adopt >= 10 ;

RETURN RES ;

EXCEPTION
WHEN NO_DATA_FOUND  THEN
             RETURN -1;
WHEN OTHERS  THEN
             RETURN -1;
END  ASSIGNING_WORK_TRANS_CHECK ;



----------------------------------------------------------------------

FUNCTION GET_EMP_ATTENDANCE_LEAVE(
ID_IN  IN NUMBER , DATE_IN IN DATE ) RETURN  VARCHAR2 IS
RES  VARCHAR2(10);
BEGIN

    select to_char(max(a.ttime),'HH24:mi') INTO RES
    from data.attendance a
    where a.employeeno= nvl(( SELECT u.EMP_NO FROM USERS_PROG_TB u WHERE u.id = ID_IN ),0)
    and  TRUNC(a.tdate) = TRUNC(DATE_IN)
    and a.status = 4 ;

    RETURN NVL(RES,'');

EXCEPTION
WHEN NO_DATA_FOUND  THEN
             RETURN '';
WHEN OTHERS  THEN
             RETURN '';
END  GET_EMP_ATTENDANCE_LEAVE ;

---------------------------------------------------------------------

FUNCTION GET_CNT_EMP_ATTENDANCE_STATUS( EMP_NO_IN  IN NUMBER , DATE_IN IN DATE , STATUS_IN IN NUMBER  ) RETURN  NUMBER IS
RES  NUMBER(3);
BEGIN

    select count(0) INTO RES
    from data.attendance a
    where a.employeeno= EMP_NO_IN
    and a.tdate= DATE_IN
    and a.status= STATUS_IN ;

    RETURN  RES ;

EXCEPTION
WHEN NO_DATA_FOUND  THEN
             RETURN -1;
WHEN OTHERS  THEN
             RETURN -1;
END  GET_CNT_EMP_ATTENDANCE_STATUS ;


----------------------------------------------------------------------
-- تحديد سجل الدوام حسب التاريخ والفئة
FUNCTION OFF_WORK_HOURS_DETECT_ROW(
TARGET_CD_IN  IN NUMBER , DATE_IN IN DATE ) RETURN  NUMBER IS
CNT1 NUMBER;
CNT2 NUMBER;
L_DATE  DATE;
RES  NUMBER;
BEGIN

L_DATE:= TRUNC(DATE_IN);

    select count(0) into CNT1
    from gfc_hr.official_work_hours_tb  a
    where a.target_cd= TARGET_CD_IN
    and a.status= 2
    and L_DATE between a.d_from and a.d_to
    and a.days like '%'||qf_pkg.get_day_name_en(L_DATE)||'%' ;

    IF CNT1= 1 THEN

        select A.ser into RES
        from gfc_hr.official_work_hours_tb  a
        where a.target_cd= TARGET_CD_IN
        and a.status= 2
        and L_DATE between a.d_from and a.d_to
        and a.days like '%'||qf_pkg.get_day_name_en(L_DATE)||'%' ;

    ELSE

        select count(0) into CNT2
        from gfc_hr.official_work_hours_tb  a
        where a.target_cd= TARGET_CD_IN
        and a.status= 1
        and L_DATE between NVL(a.d_from,'01/01/1900') and NVL(a.d_to,'01/01/3000')
        and a.days like '%'||qf_pkg.get_day_name_en(L_DATE)||'%' ;

        IF CNT2= 1 THEN

            select A.ser into RES
            from gfc_hr.official_work_hours_tb  a
            where a.target_cd= TARGET_CD_IN
            and a.status= 1
            and L_DATE between NVL(a.d_from,'01/01/1900') and NVL(a.d_to,'01/01/3000')
            and a.days like '%'||qf_pkg.get_day_name_en(L_DATE)||'%' ;

        ELSE
            RES:=0;
        END IF;

    END IF;


RETURN NVL(RES,0);

EXCEPTION
WHEN NO_DATA_FOUND  THEN
             RETURN -1;
WHEN OTHERS  THEN
             RETURN -1;
END  OFF_WORK_HOURS_DETECT_ROW ;

-----------------------------------------------------------------------

FUNCTION OFF_WORK_HOURS_DELAY_START(
SER_IN  IN NUMBER , TIME_IN IN DATE ) RETURN  NUMBER IS
CNT  NUMBER;
RES  NUMBER;
BEGIN

select TO_CHAR(TIME_IN,'HH24MI') - TO_CHAR( A.t_start + A.start_allow_period/(24*60) ,'HH24MI') INTO CNT
from gfc_hr.official_work_hours_tb  a
where a.ser= SER_IN;

IF CNT > 0 THEN
    RES:=1; -- DELAY_START - تأخير صباحي
ELSE
    RES:=0; -- NOT DELAY_START حضور طبيعي
END IF;

RETURN RES ;

EXCEPTION
WHEN NO_DATA_FOUND  THEN
             RETURN -1;
WHEN OTHERS  THEN
             RETURN -1;
END  OFF_WORK_HOURS_DELAY_START ;

-----------------------------------------------------------------------

-- عدد دقائق التأخير من ساعة بداية الدوام
FUNCTION OFF_WORK_HOURS_DELAY_START_MIN(
SER_IN  IN NUMBER , TIME_IN IN DATE ) RETURN  NUMBER IS
RES  NUMBER;
BEGIN

select ( TO_DATE('01/01/2020 '||TO_CHAR(TIME_IN,'HH24MI'), 'DD/MM/YYYY HH24MI') - TO_DATE('01/01/2020 '||TO_CHAR( A.t_start ,'HH24MI'), 'DD/MM/YYYY HH24MI') ) * 60 * 24   INTO RES
from gfc_hr.official_work_hours_tb  a
where a.ser= SER_IN;

RETURN ROUND( RES ) ;

EXCEPTION
WHEN NO_DATA_FOUND  THEN
             RETURN -1;
WHEN OTHERS  THEN
             RETURN -1;
END  OFF_WORK_HOURS_DELAY_START_MIN ;

-----------------------------------------------------------------------

FUNCTION OFF_WORK_HOURS_EARLY_END(
SER_IN  IN NUMBER , TIME_IN IN DATE ) RETURN  NUMBER IS
CNT  NUMBER;
RES  NUMBER;
BEGIN

select TO_CHAR(TIME_IN,'HH24MI') -  TO_CHAR( A.t_end - A.end_allow_period/(24*60) ,'HH24MI') INTO CNT
from gfc_hr.official_work_hours_tb  a
where a.ser= SER_IN;

IF CNT < 0 THEN
    RES:=1; -- EARLY_END - انصراف مبكر
ELSE
    RES:=0; -- NOT EARLY_END انصراف طبيعي
END IF;

RETURN RES ;

EXCEPTION
WHEN NO_DATA_FOUND  THEN
             RETURN -1;
WHEN OTHERS  THEN
             RETURN -1;
END  OFF_WORK_HOURS_EARLY_END ;

-----------------------------------------------------------------------

FUNCTION OFF_WORK_HOURS_OVER_TIME(
SER_IN  IN NUMBER , TIME_IN IN DATE ) RETURN  NUMBER IS
CNT  NUMBER;
RES  NUMBER;
BEGIN

select TO_CHAR(TIME_IN,'HH24MI') -  TO_CHAR( A.t_end + 55/(24*60) ,'HH24MI') INTO CNT
from gfc_hr.official_work_hours_tb  a
where a.ser= SER_IN;

IF CNT >= 0 THEN
    RES:=1; -- OVER_TIME - له وقت اضافي
ELSE
    RES:=0; -- NOT OVER_TIME ليس له وقت اضافي
END IF;

RETURN RES ;

EXCEPTION
WHEN NO_DATA_FOUND  THEN
             RETURN -1;
WHEN OTHERS  THEN
             RETURN -1;
END  OFF_WORK_HOURS_OVER_TIME ;

-----------------------------------------------------------------------

FUNCTION OFF_WORK_HOURS_CNT_HOURS_ADAY(
SER_IN  IN NUMBER ) RETURN  NUMBER IS
RES  NUMBER;
BEGIN

-- عدد ساعات الدوام في اليوم بعد خصم مدة السماح
select ( (A.t_end - A.t_start)*24 ) - ( (a.start_allow_period+a.end_allow_period)/ 60 ) INTO RES
from gfc_hr.official_work_hours_tb  a
where a.ser= SER_IN;

RETURN ROUND(RES,2) ;

EXCEPTION
WHEN NO_DATA_FOUND  THEN
             RETURN -1;
WHEN OTHERS  THEN
             RETURN -1;
END  OFF_WORK_HOURS_CNT_HOURS_ADAY ;

-----------------------------------------------------------------------

FUNCTION OFF_WORK_HOURS_CNT_FHOURS_ADAY(
SER_IN  IN NUMBER ) RETURN  NUMBER IS
RES  NUMBER;
BEGIN

-- عدد ساعات الدوام في اليوم بدون خصم مدة السماح
select ( (A.t_end - A.t_start)*24 ) INTO RES
from gfc_hr.official_work_hours_tb  a
where a.ser= SER_IN;

RETURN ROUND(RES,2) ;

EXCEPTION
WHEN NO_DATA_FOUND  THEN
             RETURN -1;
WHEN OTHERS  THEN
             RETURN -1;
END  OFF_WORK_HOURS_CNT_FHOURS_ADAY ;

-----------------------------------------------------------------------

FUNCTION OFF_WORK_HOURS_END_TIME(
SER_IN  IN NUMBER ) RETURN  VARCHAR2 IS
RES  VARCHAR2(8);
BEGIN

-- وقت نهاية العمل - يستخدم لاغلاق الاذونات
select  TO_CHAR(A.t_end,'HH24:MI')  INTO RES
from gfc_hr.official_work_hours_tb  a
where a.ser= SER_IN;

RETURN RES;

EXCEPTION
WHEN NO_DATA_FOUND  THEN
             RETURN '14:00';
WHEN OTHERS  THEN
             RETURN '14:00';
END  OFF_WORK_HOURS_END_TIME ;


-----------------------------------------------------------------------
----------------------------------------------------------------------

-- عدد مرات التأخير الصباحي للموظف من بداية الشهر حتى تاريخ
FUNCTION GET_EMP_DELAY_START_CNT(
EMP_NO_IN  IN NUMBER , DATE_IN IN DATE ) RETURN  NUMBER IS
RES  NUMBER;
BEGIN

SELECT count( distinct TRUNC(M.ENTRY_DATE) ) INTO RES
FROM CLOCK_DATA_VW M
WHERE TRUNC(M.ENTRY_DATE) BETWEEN TRUNC(DATE_IN,'mm') AND TRUNC(DATE_IN)
and  M.EMP_NO= EMP_NO_IN
AND  M.FUNCTION_KEY= 1  AND HR_ATTENDANCE_PKG.OFF_WORK_HOURS_DELAY_START( HR_ATTENDANCE_PKG.OFF_WORK_HOURS_DETECT_ROW(1, M.ENTRY_DATE) , M.ENTRY_DATE ) = 1 ;

RETURN  RES  ;

EXCEPTION
WHEN NO_DATA_FOUND  THEN
             RETURN -1;
WHEN OTHERS  THEN
             RETURN -1;
END  GET_EMP_DELAY_START_CNT ;

-----------------------------------------------------------------------
----------------------------------------------------------------------

-- اول بصمة حضور للموظف في اليوم
FUNCTION GET_ENTRY_TIME_EMP_DATE(
EMP_NO_IN  IN NUMBER , DATE_IN IN DATE ) RETURN DATE IS
RES DATE ;
BEGIN

    SELECT MIN(S.TTIME) INTO RES
    FROM  DATA.ATTENDANCE S
    WHERE S.EMPLOYEENO= EMP_NO_IN
    AND S.TDATE= DATE_IN
    AND S.STATUS = 1;

    RETURN RES;

EXCEPTION
WHEN NO_DATA_FOUND THEN
    RETURN NULL;
WHEN OTHERS THEN
    RETURN NULL;
END GET_ENTRY_TIME_EMP_DATE;

----------------------------------------------------------------------

-- اخر بصمة انصراف للموظف في اليوم
-- وفي حال عدم وجودها يتم عرض اول بصمة انصراف في اليوم التالي اذا كانت قبل الحضور
FUNCTION GET_LEAVE_TIME_EMP_DATE(
EMP_NO_IN  IN NUMBER , DATE_IN IN DATE ) RETURN DATE IS
RES DATE;
L_ENTRY_TIME DATE;
L_LEAVE_TIME DATE;
BEGIN

    SELECT MAX(S.TTIME) INTO RES
    FROM  DATA.ATTENDANCE S
    WHERE S.EMPLOYEENO= EMP_NO_IN
    AND S.TDATE= DATE_IN
    AND S.STATUS= 4;

    SELECT MIN(D.TTIME) + INTERVAL '10' MINUTE  INTO L_ENTRY_TIME
    FROM  DATA.ATTENDANCE D
    WHERE D.EMPLOYEENO= EMP_NO_IN
    AND D.TDATE= DATE_IN
    AND D.STATUS= 1;

    IF L_ENTRY_TIME IS NULL  OR  RES > L_ENTRY_TIME THEN
    	RES:= RES;
    ELSE
        RES:= NULL;
    END IF;

IF RES IS NULL THEN

    L_ENTRY_TIME:= NULL;

    SELECT MIN(D.TTIME) + INTERVAL '10' MINUTE  INTO L_ENTRY_TIME
    FROM  DATA.ATTENDANCE D
    WHERE D.EMPLOYEENO= EMP_NO_IN
    AND D.TDATE= DATE_IN +1
    AND D.STATUS= 1;

    SELECT MIN(S.TTIME) INTO L_LEAVE_TIME
    FROM  DATA.ATTENDANCE S
    WHERE S.EMPLOYEENO= EMP_NO_IN
    AND S.TDATE= DATE_IN +1
    AND S.STATUS= 4;

    IF L_LEAVE_TIME < L_ENTRY_TIME THEN
    	RES:= L_LEAVE_TIME;
    END IF;

END IF;


RETURN RES;

EXCEPTION
WHEN NO_DATA_FOUND THEN
    RETURN NULL;
WHEN OTHERS THEN
    RETURN NULL;
END GET_LEAVE_TIME_EMP_DATE ;


-------------------------------شاشة اضافة بصمة ---------------------------------------------
PROCEDURE FINGER_ATTENDANCE_INSERT (
EMPLOYEENO_IN  IN DATA.ATTENDANCE.EMPLOYEENO%TYPE ,
STATUS_IN  IN DATA.ATTENDANCE.STATUS%TYPE ,
TDATE_IN  IN VARCHAR2 ,
TTIME_IN  IN VARCHAR2 ,
REASON_IN  IN DATA.ATTENDANCE.REASON%TYPE ,
MSG_OUT OUT VARCHAR2) AS
V_TIME_DATE DATE;
SEQ_VAL NUMBER;
BEGIN

if TTIME_IN is null then
    V_TIME_DATE:= '';
ELSE
    V_TIME_DATE:= TO_DATE(TDATE_IN||TTIME_IN,'DD/MM/YYYY HH24:MI');
END if;

SEQ_VAL := CLOCK_DATA_TB_SEQ.NEXTVAL;

INSERT INTO  DATA.ATTENDANCE
(NO,EMPLOYEENO,EMP_BRANCH ,TDATE ,TTIME ,STATUS,REASON,ENTRY_USER,ENTRY_DATE,EMP_TYPE,TERMINAL)
 VALUES
(SEQ_VAL,EMPLOYEENO_IN,GET_EMP_BRAN_EMPLOYEE(EMPLOYEENO_IN) ,TDATE_IN ,V_TIME_DATE , STATUS_IN, REASON_IN,USER_PKG.GET_USER_ID,SYSDATE,30,'مدخل من النظام الاداري'  ) ;

MSG_OUT:= SQL%ROWCOUNT;

EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'FINGER_ATTENDANCE_INSERT '|| SQLERRM;
END FINGER_ATTENDANCE_INSERT ;
-----------------------------------------------------------------------------
PROCEDURE FINGER_ATTENDANCE_DELETE (
NO_IN  IN DATA.ATTENDANCE.NO%TYPE ,
EMPLOYEENO_IN  IN DATA.ATTENDANCE.EMPLOYEENO%TYPE ,
MSG_OUT OUT VARCHAR2) AS
BEGIN

DELETE FROM DATA.ATTENDANCE M WHERE
M.NO = NO_IN AND M.EMPLOYEENO = EMPLOYEENO_IN AND M.ENTRY_USER = USER_PKG.GET_USER_ID AND M.ENTRY_DATE >= TRUNC(SYSDATE - 5);

MSG_OUT:=  SQL%ROWCOUNT;

EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'FINGER_ATTENDANCE_DELETE '|| SQLERRM;
END FINGER_ATTENDANCE_DELETE ;
-----------------------------------------------------------------------------
PROCEDURE FINGER_ATTENDANCE_LIST (INSQL IN VARCHAR2 ,
 OFFSET    NUMBER,ROW    NUMBER ,
  REF_CUR_OUT OUT SYS_REFCURSOR,MSG_OUT OUT VARCHAR2  ) AS
 XSQL VARCHAR2(4000);
BEGIN
XSQL:= 'SELECT * FROM (
SELECT  M.* ,
EMP_PKG.GET_EMP_NAME( M.EMPLOYEENO)  EMP_NAME ,
SETTING_PKG.CONSTANT_DETAILS_TB_GET_NAME(225 ,M.STATUS)  STATUS_NAME ,
TO_CHAR(M.TDATE, ''DD/MM/YYYY'')  ATTENDANCE_DATE ,
TO_CHAR(M.TTIME, ''HH24:MI'') ATTENDANCE_TIME ,
TO_CHAR(M.ENTRY_DATE,''HH24:MI DD/MM/YYYY '') ENTRY_DATE_TIME ,
USER_PKG.GET_USER_NAME(M.ENTRY_USER)  ENTRY_USER_NAME ,
ROW_NUMBER() OVER ( ORDER BY  M.NO DESC) RN
FROM DATA.ATTENDANCE  M    '||INSQL||'    ORDER BY M.NO DESC )
WHERE RN BETWEEN '||(OFFSET +1)||' AND '|| ROW ||' ORDER BY RN ';
OPEN REF_CUR_OUT FOR XSQL;
 MSG_OUT:= 1;
EXCEPTION
WHEN OTHERS THEN
MSG_OUT :=  'HR_ATTENDANCE_PKG'||'FINGER_ATTENDANCE_LIST '|| SQLERRM;
END  FINGER_ATTENDANCE_LIST ;

-----------------------------------------------------------
FUNCTION GET_EMP_BRAN_EMPLOYEE(
NO_IN  IN DATA.EMPLOYEES.NO%TYPE
) RETURN  NUMBER IS
RES  NUMBER;
BEGIN

IF NO_IN >= 70000 THEN
    SELECT  M.BRANCH INTO RES  FROM EMPLOYEES_TB M
    WHERE  M.NO = NO_IN;
ELSE
    SELECT  M.BRAN INTO RES  FROM DATA.EMPLOYEES M
    WHERE  M.NO = NO_IN;
END IF;

RETURN NVL(RES,0) ;

EXCEPTION
WHEN NO_DATA_FOUND  THEN
             RETURN 0;
WHEN OTHERS  THEN
             RETURN 0;
END  GET_EMP_BRAN_EMPLOYEE ;


END ;